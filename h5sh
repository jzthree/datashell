#!/usr/bin/env python3
"""h5sh - Interactive HDF5 file explorer. A better h5ls.

Navigate HDF5 files like a filesystem with tab completion,
smart array previews, slicing, and built-in analysis.

Usage:
    h5sh data.h5              Interactive shell
    h5sh data.h5 -l           List root (like h5ls)
    h5sh data.h5 -d /weights  Dump dataset (like h5ls -d)
    h5sh data.h5 -c 'tree'    Run command and exit
"""

import cmd
import sys
import os
import re
import textwrap
import shutil
import readline
import curses
import termios
import tty
import select
import fcntl
import struct

try:
    import h5py
except ImportError:
    print("h5sh requires h5py: pip install h5py", file=sys.stderr)
    sys.exit(1)

try:
    import numpy as np
except ImportError:
    print("h5sh requires numpy: pip install numpy", file=sys.stderr)
    sys.exit(1)


# ── ANSI colors ─────────────────────────────────────────────

class C:
    BLUE = '\033[34m'
    CYAN = '\033[36m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    RED = '\033[31m'
    MAGENTA = '\033[35m'
    DIM = '\033[2m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @classmethod
    def disable(cls):
        for attr in ('BLUE', 'CYAN', 'GREEN', 'YELLOW', 'RED',
                      'MAGENTA', 'DIM', 'BOLD', 'RESET'):
            setattr(cls, attr, '')


# ── Helpers ──────────────────────────────────────────────────

def format_size(nbytes):
    for unit in ('B', 'KB', 'MB', 'GB', 'TB'):
        if abs(nbytes) < 1024:
            if nbytes == int(nbytes):
                return f"{int(nbytes)} {unit}"
            return f"{nbytes:.1f} {unit}"
        nbytes /= 1024
    return f"{nbytes:.1f} PB"


def parse_slice(s):
    """Parse numpy-style slice: '0:10, :5' -> tuple of slices/ints."""
    s = s.strip()
    if s.startswith('[') and s.endswith(']'):
        s = s[1:-1]

    parts = s.split(',')
    result = []
    for part in parts:
        part = part.strip()
        if part == '...' or part == 'Ellipsis':
            result.append(Ellipsis)
        elif ':' in part:
            pieces = part.split(':')
            start = int(pieces[0]) if pieces[0].strip() else None
            stop = int(pieces[1]) if len(pieces) > 1 and pieces[1].strip() else None
            step = int(pieces[2]) if len(pieces) > 2 and pieces[2].strip() else None
            result.append(slice(start, stop, step))
        else:
            result.append(int(part))

    return tuple(result) if len(result) > 1 else result[0]


def _is_numeric(dtype):
    return np.issubdtype(dtype, np.number)


def _is_string(dtype):
    return (np.issubdtype(dtype, np.bytes_)
            or np.issubdtype(dtype, np.str_)
            or h5py.check_string_dtype(dtype) is not None)


BLOCKS = ' \u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588'  # ▁▂▃▄▅▆▇█


def _rgb_to_256(r, g, b):
    """Map RGB (0-255) to nearest xterm-256 color index."""
    r6 = round(r / 255 * 5)
    g6 = round(g / 255 * 5)
    b6 = round(b / 255 * 5)
    return 16 + 36 * r6 + 6 * g6 + b6


# 64-entry viridis approximation as (R, G, B) 0-255
VIRIDIS_64 = [
    (68, 1, 84), (70, 8, 92), (71, 16, 99), (72, 23, 105),
    (72, 29, 111), (71, 36, 117), (70, 42, 122), (68, 48, 127),
    (65, 54, 130), (62, 59, 133), (58, 65, 134), (54, 70, 135),
    (50, 75, 135), (46, 80, 134), (42, 85, 133), (38, 90, 131),
    (35, 94, 129), (31, 99, 126), (28, 103, 123), (25, 107, 120),
    (23, 111, 116), (21, 115, 112), (20, 119, 108), (21, 123, 103),
    (23, 126, 98), (27, 130, 93), (33, 133, 87), (40, 137, 82),
    (48, 140, 76), (57, 143, 70), (67, 146, 63), (77, 149, 56),
    (88, 152, 49), (99, 154, 42), (110, 156, 36), (122, 158, 30),
    (133, 160, 24), (144, 161, 20), (155, 162, 17), (166, 162, 15),
    (176, 161, 14), (186, 160, 15), (196, 158, 18), (205, 155, 22),
    (214, 151, 28), (222, 146, 35), (229, 141, 42), (235, 135, 50),
    (241, 128, 58), (245, 121, 66), (249, 113, 74), (251, 105, 82),
    (253, 97, 90), (253, 89, 97), (253, 81, 104), (251, 73, 111),
    (249, 65, 117), (245, 57, 123), (241, 50, 128), (236, 43, 133),
    (230, 37, 137), (224, 31, 141), (217, 25, 144), (210, 20, 146),
]

# Precomputed ANSI 256-color indices for viridis
VIRIDIS_ANSI = [_rgb_to_256(r, g, b) for r, g, b in VIRIDIS_64]


# ── Main shell ───────────────────────────────────────────────

class H5Shell(cmd.Cmd):

    def __init__(self, filename, no_color=False):
        super().__init__()
        if no_color or not sys.stdout.isatty():
            C.disable()

        self.filename = os.path.abspath(filename)
        self.basename = os.path.basename(filename)
        self.file = h5py.File(filename, 'r')
        self.cwd = '/'
        self._prev_cwd = '/'
        self.dark_bg = self._detect_dark_bg()
        self.sixel = self._detect_sixel()
        self._update_prompt()

        # Readline: treat / as a delimiter for path completion
        readline.set_completer_delims(' \t\n')

        # Build intro
        n_datasets = [0]
        n_groups = [0]
        def _count(name, obj):
            if isinstance(obj, h5py.Dataset):
                n_datasets[0] += 1
            elif isinstance(obj, h5py.Group):
                n_groups[0] += 1
        self.file.visititems(_count)

        fsize = format_size(os.path.getsize(filename))
        self.intro = (
            f"\n{C.BOLD}h5sh{C.RESET} - {C.CYAN}{self.basename}{C.RESET}"
            f"  ({fsize}, {n_groups[0]} groups, {n_datasets[0]} datasets)\n"
            f"Type {C.GREEN}help{C.RESET} for commands, "
            f"{C.GREEN}tree{C.RESET} for overview, "
            f"{C.GREEN}q{C.RESET} to quit.\n"
        )

    # ── Path resolution ──────────────────────────────────────

    def _update_prompt(self):
        self.prompt = f"{C.BOLD}h5sh{C.RESET}:{C.BLUE}{self.cwd}{C.RESET}> "

    @staticmethod
    def _detect_dark_bg():
        """Guess if terminal has dark background."""
        fg_bg = os.environ.get('COLORFGBG', '')
        if fg_bg:
            try:
                bg = int(fg_bg.split(';')[-1])
                return bg < 8
            except Exception:
                pass
        return False

    @staticmethod
    def _detect_sixel():
        """Detect sixel support via DA1 terminal query."""
        fd = sys.stdin.fileno()
        if not os.isatty(fd):
            return False
        old = termios.tcgetattr(fd)
        try:
            tty.setcbreak(fd)
            sys.stdout.write('\033[c')
            sys.stdout.flush()
            buf = []
            while select.select([fd], [], [], 0.5)[0]:
                ch = os.read(fd, 1)
                buf.append(ch)
                if ch == b'c':
                    break
            resp = b''.join(buf).decode('ascii', errors='ignore')
            if '?' in resp:
                params = resp.split('?')[-1].rstrip('c').split(';')
                return '4' in params
        except Exception:
            pass
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)
        return False

    def _get_terminal_pixels(self):
        """Query terminal pixel dimensions. Returns (rows, cols, xpix, ypix)."""
        try:
            fd = sys.stdin.fileno()
            result = fcntl.ioctl(fd, termios.TIOCGWINSZ, b'\x00' * 8)
            rows, cols, xpix, ypix = struct.unpack('HHHH', result)
            if xpix > 0 and ypix > 0:
                return rows, cols, xpix, ypix
        except Exception:
            pass
        rows, cols = shutil.get_terminal_size()
        return rows, cols, cols * 8, rows * 16

    def _resolve(self, path):
        """Resolve path relative to cwd. Handles .., /, and relative."""
        if not path or path == '.':
            return self.cwd
        if path == '-':
            return self._prev_cwd
        if path.startswith('/'):
            parts = path.split('/')
        else:
            base = self.cwd.rstrip('/').split('/')
            parts = base + path.split('/')

        result = []
        for p in parts:
            if p == '' or p == '.':
                continue
            elif p == '..':
                if result:
                    result.pop()
            else:
                result.append(p)
        return '/' + '/'.join(result) if result else '/'

    def _get(self, path):
        """Get HDF5 object at path (resolved)."""
        resolved = self._resolve(path)
        if resolved == '/':
            return self.file
        try:
            return self.file[resolved]
        except KeyError:
            return None

    def _parse_name_slice(self, arg):
        """Split 'dataset[0:10, :5]' into (name, slice_or_None)."""
        m = re.match(r'^(.+?)(\[.+\])\s*$', arg)
        if m:
            name = m.group(1).strip()
            try:
                sl = parse_slice(m.group(2))
                return name, sl
            except (ValueError, IndexError):
                print(f"{C.RED}Invalid slice: {m.group(2)}{C.RESET}")
                return name, 'ERROR'
        return arg.strip(), None

    # ── Tab completion ───────────────────────────────────────

    def _complete_path(self, text, line, begidx, endidx):
        """Complete HDF5 paths (used by all commands)."""
        if '/' in text:
            parent_str = text.rsplit('/', 1)[0]
            prefix = text.rsplit('/', 1)[1]
            parent_path = self._resolve(parent_str) if parent_str else '/'
            prepend = parent_str + '/'
        else:
            parent_path = self.cwd
            prefix = text
            prepend = ''

        obj = self._get(parent_path) if parent_path else self._get('/')
        if obj is None or not isinstance(obj, h5py.Group):
            return []

        completions = []
        for name in obj:
            if name.lower().startswith(prefix.lower()):
                child = obj[name]
                suffix = '/' if isinstance(child, h5py.Group) else ''
                completions.append(prepend + name + suffix)
        return completions

    # ── Formatting ───────────────────────────────────────────

    def _format_array(self, data, max_rows=20, max_cols=None):
        if max_cols is None:
            tw = shutil.get_terminal_size((80, 24)).columns
            max_cols = max(tw // 12, 5)

        if isinstance(data, bytes):
            return data.decode('utf-8', errors='replace')
        if isinstance(data, np.bytes_):
            return bytes(data).decode('utf-8', errors='replace')
        if isinstance(data, (str, np.str_)):
            return str(data)

        if isinstance(data, np.ndarray):
            if _is_string(data.dtype):
                # Pretty-print string arrays
                flat = data.flatten()
                lines = []
                for i, v in enumerate(flat):
                    if i >= max_rows * max_cols:
                        lines.append(f'  ... ({len(flat)} total)')
                        break
                    s = v.decode('utf-8', errors='replace') if isinstance(v, bytes) else str(v)
                    lines.append(f'  [{i}] "{s}"')
                return '\n'.join(lines)

            tw = shutil.get_terminal_size((80, 24)).columns
            with np.printoptions(
                threshold=max_rows * max_cols,
                linewidth=tw - 2,
                edgeitems=min(5, max_cols // 2),
                precision=6,
                suppress=True,
            ):
                return str(data)
        return str(data)

    def _entry_line(self, name, obj, long_fmt=False):
        if isinstance(obj, h5py.Group):
            n = len(obj)
            if long_fmt:
                return f"  {C.BLUE}{C.BOLD}{name}/{C.RESET}  {C.DIM}({n} items){C.RESET}"
            return f"  {C.BLUE}{C.BOLD}{name}/{C.RESET}"

        elif isinstance(obj, h5py.Dataset):
            shape_s = '\u00d7'.join(str(s) for s in obj.shape) if obj.shape else 'scalar'
            dt = str(obj.dtype)
            if _is_string(obj.dtype):
                dt = 'string'
            if long_fmt:
                storage = format_size(obj.id.get_storage_size())
                chunks = str(obj.chunks) if obj.chunks else 'contig'
                comp = obj.compression or 'none'
                if obj.compression_opts:
                    comp += f'({obj.compression_opts})'
                n_attrs = len(obj.attrs)
                attr_s = f"  {C.DIM}+{n_attrs} attrs{C.RESET}" if n_attrs else ""
                return (
                    f"  {C.GREEN}{name}{C.RESET}  "
                    f"{C.YELLOW}{shape_s}{C.RESET} {C.DIM}{dt}{C.RESET}  "
                    f"{storage}  {C.DIM}chunks={chunks}  {comp}{C.RESET}"
                    f"{attr_s}"
                )
            return f"  {C.GREEN}{name}{C.RESET}  {C.DIM}{shape_s} {dt}{C.RESET}"

    # ── Navigation commands ──────────────────────────────────

    def do_ls(self, arg):
        """List contents.  Usage: ls [-l] [path]
        -l  long format (shape, dtype, size, chunks, compression)"""
        long_fmt = False
        parts = arg.split()
        if '-l' in parts:
            long_fmt = True
            parts.remove('-l')
        path = parts[0] if parts else ''

        obj = self._get(path)
        if obj is None:
            print(f"{C.RED}Not found: {path}{C.RESET}")
            return

        if isinstance(obj, h5py.Dataset):
            print(self._entry_line(obj.name.rsplit('/', 1)[-1], obj, long_fmt=True))
            return

        if not isinstance(obj, h5py.Group):
            print(f"{C.RED}Not a group or dataset{C.RESET}")
            return

        items = sorted(obj.keys())
        if not items:
            print(f"  {C.DIM}(empty){C.RESET}")
            return

        # Groups first, then datasets
        groups = [(n, obj[n]) for n in items if isinstance(obj[n], h5py.Group)]
        datasets = [(n, obj[n]) for n in items if isinstance(obj[n], h5py.Dataset)]
        for n, o in groups:
            print(self._entry_line(n, o, long_fmt))
        for n, o in datasets:
            print(self._entry_line(n, o, long_fmt))

    complete_ls = _complete_path

    def do_ll(self, arg):
        """Alias for ls -l."""
        self.do_ls(f'-l {arg}')

    complete_ll = _complete_path

    def do_cd(self, arg):
        """Change group.  Usage: cd [path]   (cd .. / cd / / cd - supported)"""
        if not arg or arg.strip() == '/':
            self._prev_cwd = self.cwd
            self.cwd = '/'
            self._update_prompt()
            return

        target = self._resolve(arg.strip())
        obj = self._get(target)
        if obj is None:
            print(f"{C.RED}Not found: {arg}{C.RESET}")
        elif not isinstance(obj, h5py.Group):
            print(f"{C.RED}Not a group: {arg}{C.RESET}")
        else:
            self._prev_cwd = self.cwd
            self.cwd = target
            self._update_prompt()

    complete_cd = _complete_path

    def do_pwd(self, arg):
        """Print current path."""
        print(self.cwd)

    def do_tree(self, arg):
        """Recursive listing.  Usage: tree [-d DEPTH] [-L LIMIT] [path]
        -d N   max depth (default: unlimited)
        -L N   max items before truncation (default: 200)"""
        parts = arg.split()
        max_depth = None
        max_items = 200
        path = ''

        i = 0
        while i < len(parts):
            if parts[i] == '-d' and i + 1 < len(parts):
                max_depth = int(parts[i + 1])
                i += 2
            elif parts[i] == '-L' and i + 1 < len(parts):
                max_items = int(parts[i + 1])
                i += 2
            else:
                path = parts[i]
                i += 1

        obj = self._get(path)
        if obj is None:
            print(f"{C.RED}Not found: {path}{C.RESET}")
            return

        if isinstance(obj, h5py.Dataset):
            shape_s = '\u00d7'.join(str(s) for s in obj.shape)
            print(f"{C.GREEN}{obj.name}{C.RESET}  {C.DIM}{shape_s} {obj.dtype}{C.RESET}")
            return

        display = path if path else self.cwd
        print(f"{C.BOLD}{display}{C.RESET}")

        count = [0]
        truncated = [False]

        def walk(group, prefix='', depth=0):
            if truncated[0]:
                return
            if max_depth is not None and depth >= max_depth:
                if len(group) > 0:
                    print(f"{prefix}{C.DIM}... (depth limit){C.RESET}")
                return

            items = sorted(group.keys())
            for i, name in enumerate(items):
                if truncated[0]:
                    return
                is_last = (i == len(items) - 1)
                connector = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '
                child = group[name]
                count[0] += 1

                if count[0] > max_items:
                    print(f"{prefix}{C.YELLOW}... truncated at {max_items} items "
                          f"(use -L to increase){C.RESET}")
                    truncated[0] = True
                    return

                if isinstance(child, h5py.Group):
                    n = len(child)
                    print(f"{prefix}{connector}{C.BLUE}{C.BOLD}{name}/{C.RESET}"
                          f" {C.DIM}({n}){C.RESET}")
                    extension = '    ' if is_last else '\u2502   '
                    walk(child, prefix + extension, depth + 1)
                else:
                    shape_s = '\u00d7'.join(str(s) for s in child.shape) if child.shape else 'scalar'
                    dt = 'string' if _is_string(child.dtype) else str(child.dtype)
                    print(f"{prefix}{connector}{C.GREEN}{name}{C.RESET}"
                          f" {C.DIM}{shape_s} {dt}{C.RESET}")

        walk(obj)

    complete_tree = _complete_path

    # ── Data viewing ─────────────────────────────────────────

    def do_cat(self, arg):
        """Print dataset values.  Usage: cat <dataset>[slice]

        Examples:
            cat weights              Full dump (warns if >10k elements)
            cat weights[0]           Single element
            cat weights[0:10]        First 10 rows
            cat weights[0:10, :5]    2D slice
            cat weights[::100]       Every 100th row
            cat weights[-5:]         Last 5 rows
        """
        if not arg:
            print("Usage: cat <dataset>[slice]")
            return

        name, sl = self._parse_name_slice(arg)
        if sl == 'ERROR':
            return

        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return

        total = int(np.prod(obj.shape)) if obj.shape else 1

        if sl is not None:
            data = obj[sl]
            if isinstance(data, np.ndarray):
                result_size = data.size
            else:
                result_size = 1
            if result_size > 100_000:
                print(f"{C.YELLOW}Slice still has {result_size:,} elements. "
                      f"Showing first portion:{C.RESET}")
        elif total > 10_000:
            print(f"{C.YELLOW}Dataset has {total:,} elements. "
                  f"Use a slice or 'peek {name}'.{C.RESET}")
            print(f"  {C.DIM}cat {name}[0:10]   cat {name}[:5, :5]   "
                  f"head {name}   peek {name}{C.RESET}")
            return
        else:
            data = obj[()]

        print(self._format_array(data))

    complete_cat = _complete_path

    def do_head(self, arg):
        """First N elements.  Usage: head [-n N] <dataset>  (default N=10)"""
        n = 10
        parts = arg.split()
        if '-n' in parts:
            idx = parts.index('-n')
            if idx + 1 < len(parts):
                n = int(parts[idx + 1])
                parts = parts[:idx] + parts[idx + 2:]
        if not parts:
            print("Usage: head [-n N] <dataset>")
            return

        name = parts[0]
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return
        if not obj.shape:
            print(obj[()])
            return

        actual = min(n, obj.shape[0])
        data = obj[:actual]
        shape_s = '\u00d7'.join(str(s) for s in obj.shape)
        print(f"{C.DIM}[0:{actual}] of {shape_s} {obj.dtype}{C.RESET}")
        print(self._format_array(data))

    complete_head = _complete_path

    def do_tail(self, arg):
        """Last N elements.  Usage: tail [-n N] <dataset>  (default N=10)"""
        n = 10
        parts = arg.split()
        if '-n' in parts:
            idx = parts.index('-n')
            if idx + 1 < len(parts):
                n = int(parts[idx + 1])
                parts = parts[:idx] + parts[idx + 2:]
        if not parts:
            print("Usage: tail [-n N] <dataset>")
            return

        name = parts[0]
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return
        if not obj.shape:
            print(obj[()])
            return

        actual = min(n, obj.shape[0])
        start = obj.shape[0] - actual
        data = obj[start:]
        shape_s = '\u00d7'.join(str(s) for s in obj.shape)
        print(f"{C.DIM}[{start}:{obj.shape[0]}] of {shape_s} {obj.dtype}{C.RESET}")
        print(self._format_array(data))

    complete_tail = _complete_path

    def do_peek(self, arg):
        """Smart preview — shows corners/summary for large arrays.
        Usage: peek <dataset>"""
        if not arg:
            print("Usage: peek <dataset>")
            return

        name = arg.strip()
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return

        shape_s = '\u00d7'.join(str(s) for s in obj.shape) if obj.shape else 'scalar'
        dt = 'string' if _is_string(obj.dtype) else str(obj.dtype)
        total = int(np.prod(obj.shape)) if obj.shape else 1
        storage = format_size(obj.id.get_storage_size())
        print(f"  {C.BOLD}{name}{C.RESET}  {C.YELLOW}{shape_s}{C.RESET}"
              f" {C.DIM}{dt}  {storage}{C.RESET}")
        print()

        # Scalar
        if not obj.shape:
            print(f"  {self._format_array(obj[()])}")
            return

        ndim = len(obj.shape)

        if total <= 200:
            # Small enough to show fully
            print(self._format_array(obj[()]))
            return

        if ndim == 1:
            n = obj.shape[0]
            head = obj[:5]
            tail = obj[-5:]
            print(f"  First 5:  {self._format_array(head)}")
            print(f"  {C.DIM}...({n - 10:,} more)...{C.RESET}")
            print(f"  Last 5:   {self._format_array(tail)}")

            if _is_numeric(obj.dtype):
                # Quick stats from sample
                sample_step = max(1, n // 10000)
                sample = obj[::sample_step]
                print(f"\n  {C.DIM}range: [{np.nanmin(sample):.6g}, "
                      f"{np.nanmax(sample):.6g}]  "
                      f"mean: {np.nanmean(sample):.6g}{C.RESET}")

        elif ndim == 2:
            rows, cols = obj.shape
            cr = min(6, rows)
            cc = min(10, cols)

            corner = obj[:cr, :cc]
            print(f"  Top-left [{cr}\u00d7{cc}]:")
            if _is_numeric(obj.dtype):
                for row in corner:
                    vals = '  '.join(
                        f'{v:>10.4g}' if np.issubdtype(type(v), np.floating) else f'{v:>10}'
                        for v in row
                    )
                    print(f"    {vals}")
            else:
                for row in corner:
                    print(f"    {self._format_array(row)}")

            if rows > cr:
                print(f"  {C.DIM}... ({rows - cr} more rows){C.RESET}")
            if cols > cc:
                print(f"  {C.DIM}... ({cols - cc} more cols){C.RESET}")

            if _is_numeric(obj.dtype):
                sample_step = max(1, rows // 1000)
                sample = obj[::sample_step]
                print(f"\n  {C.DIM}range: [{np.nanmin(sample):.6g}, "
                      f"{np.nanmax(sample):.6g}]  "
                      f"mean: {np.nanmean(sample):.6g}{C.RESET}")

        else:  # ndim >= 3
            print(f"  First slice [{name}[0]]:")
            first = obj[0]
            with np.printoptions(threshold=60, edgeitems=3, linewidth=78):
                print(textwrap.indent(str(first), '    '))

            if obj.shape[0] > 2:
                print(f"  {C.DIM}...({obj.shape[0] - 2} more slices)...{C.RESET}")

            if obj.shape[0] > 1:
                print(f"  Last slice [{name}[{obj.shape[0]-1}]]:")
                last = obj[-1]
                with np.printoptions(threshold=60, edgeitems=3, linewidth=78):
                    print(textwrap.indent(str(last), '    '))

    complete_peek = _complete_path

    # ── Metadata ─────────────────────────────────────────────

    def do_info(self, arg):
        """Detailed metadata.  Usage: info [name]  (default: current group)"""
        name = arg.strip() if arg.strip() else '.'
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return

        if isinstance(obj, h5py.Dataset):
            shape_s = '\u00d7'.join(str(s) for s in obj.shape) if obj.shape else 'scalar'
            storage = obj.id.get_storage_size()
            raw = int(np.prod(obj.shape)) * obj.dtype.itemsize if obj.shape else obj.dtype.itemsize
            ratio = raw / storage if storage > 0 else 0

            print(f"  {C.BOLD}Path:{C.RESET}        {obj.name}")
            print(f"  {C.BOLD}Shape:{C.RESET}       {shape_s}")
            print(f"  {C.BOLD}Dtype:{C.RESET}       {obj.dtype}")
            print(f"  {C.BOLD}Chunks:{C.RESET}      {obj.chunks if obj.chunks else 'contiguous'}")
            comp = obj.compression or 'none'
            if obj.compression_opts:
                comp += f' (level {obj.compression_opts})'
            print(f"  {C.BOLD}Compression:{C.RESET} {comp}")
            shuffle = 'yes' if obj.shuffle else 'no'
            print(f"  {C.BOLD}Shuffle:{C.RESET}     {shuffle}")
            print(f"  {C.BOLD}Storage:{C.RESET}     {format_size(storage)}"
                  f" (raw {format_size(raw)}, ratio {ratio:.1f}\u00d7)")
            if obj.maxshape and obj.maxshape != obj.shape:
                print(f"  {C.BOLD}Maxshape:{C.RESET}   {obj.maxshape}")
            if obj.fillvalue is not None:
                print(f"  {C.BOLD}Fillvalue:{C.RESET}  {obj.fillvalue}")

            if obj.attrs:
                print(f"  {C.BOLD}Attributes:{C.RESET} ({len(obj.attrs)})")
                for k, v in obj.attrs.items():
                    vs = str(v)
                    if len(vs) > 80:
                        vs = vs[:77] + '...'
                    print(f"    {C.CYAN}{k}{C.RESET} = {vs}")

        elif isinstance(obj, h5py.Group):
            n_direct = len(obj)
            n_total = [0]
            n_ds = [0]
            total_storage = [0]

            def _count(n, o):
                n_total[0] += 1
                if isinstance(o, h5py.Dataset):
                    n_ds[0] += 1
                    total_storage[0] += o.id.get_storage_size()
            obj.visititems(_count)

            print(f"  {C.BOLD}Path:{C.RESET}     {obj.name}")
            print(f"  {C.BOLD}Children:{C.RESET} {n_direct} direct, "
                  f"{n_total[0]} total ({n_ds[0]} datasets)")
            print(f"  {C.BOLD}Storage:{C.RESET}  {format_size(total_storage[0])}")

            if obj.attrs:
                print(f"  {C.BOLD}Attributes:{C.RESET} ({len(obj.attrs)})")
                for k, v in obj.attrs.items():
                    vs = str(v)
                    if len(vs) > 80:
                        vs = vs[:77] + '...'
                    print(f"    {C.CYAN}{k}{C.RESET} = {vs}")

    complete_info = _complete_path

    def do_shape(self, arg):
        """Show dataset shape.  Usage: shape <dataset>"""
        if not arg:
            print("Usage: shape <dataset>")
            return
        obj = self._get(arg.strip())
        if obj is None:
            print(f"{C.RED}Not found: {arg}{C.RESET}")
        elif isinstance(obj, h5py.Dataset):
            print(obj.shape)
        else:
            print(f"{C.RED}Not a dataset: {arg}{C.RESET}")

    complete_shape = _complete_path

    def do_dtype(self, arg):
        """Show dataset dtype.  Usage: dtype <dataset>"""
        if not arg:
            print("Usage: dtype <dataset>")
            return
        obj = self._get(arg.strip())
        if obj is None:
            print(f"{C.RED}Not found: {arg}{C.RESET}")
        elif isinstance(obj, h5py.Dataset):
            print(obj.dtype)
        else:
            print(f"{C.RED}Not a dataset: {arg}{C.RESET}")

    complete_dtype = _complete_path

    def do_attrs(self, arg):
        """Show HDF5 attributes.  Usage: attrs [name]  (default: current group)"""
        name = arg.strip() if arg.strip() else '.'
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not obj.attrs:
            print(f"  {C.DIM}(no attributes){C.RESET}")
            return
        for k, v in obj.attrs.items():
            vs = str(v)
            if len(vs) > 120:
                vs = vs[:117] + '...'
            print(f"  {C.CYAN}{k}{C.RESET} = {vs}")

    complete_attrs = _complete_path

    # ── Analysis ─────────────────────────────────────────────

    def do_stats(self, arg):
        """Statistics.  Usage: stats <dataset>[slice]
        Shows min, max, mean, std, median, zeros, NaN count."""
        if not arg:
            print("Usage: stats <dataset>[slice]")
            return

        name, sl = self._parse_name_slice(arg)
        if sl == 'ERROR':
            return

        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return

        total = int(np.prod(obj.shape)) if obj.shape else 1
        sampled = False

        if sl is not None:
            data = obj[sl]
        elif total > 10_000_000:
            sampled = True
            step = max(1, obj.shape[0] // (1_000_000 // max(1, int(np.prod(obj.shape[1:])) if len(obj.shape) > 1 else 1)))
            step = max(1, step)
            data = obj[::step]
        else:
            data = obj[()]

        data = np.asarray(data)

        if not _is_numeric(data.dtype):
            flat = data.flatten()
            uniq = np.unique(flat)
            print(f"  {C.BOLD}Shape:{C.RESET}   {data.shape}")
            print(f"  {C.BOLD}Dtype:{C.RESET}   {data.dtype}")
            print(f"  {C.BOLD}Unique:{C.RESET}  {len(uniq)}")
            return

        flat = data.astype(np.float64).flatten()
        nan_mask = np.isnan(flat)
        nan_count = int(np.sum(nan_mask))
        clean = flat[~nan_mask]

        if sampled:
            print(f"  {C.DIM}(sampled {data.size:,} of {total:,} elements){C.RESET}")

        print(f"  {C.BOLD}Shape:{C.RESET}   {data.shape}")
        print(f"  {C.BOLD}Dtype:{C.RESET}   {obj.dtype}")
        if clean.size > 0:
            print(f"  {C.BOLD}Min:{C.RESET}     {np.min(clean):.6g}")
            print(f"  {C.BOLD}Max:{C.RESET}     {np.max(clean):.6g}")
            print(f"  {C.BOLD}Mean:{C.RESET}    {np.mean(clean):.6g}")
            print(f"  {C.BOLD}Std:{C.RESET}     {np.std(clean):.6g}")
            print(f"  {C.BOLD}Median:{C.RESET}  {np.median(clean):.6g}")
            pcts = np.percentile(clean, [1, 25, 75, 99])
            print(f"  {C.BOLD}P1/P25/P75/P99:{C.RESET} {pcts[0]:.4g} / {pcts[1]:.4g} / {pcts[2]:.4g} / {pcts[3]:.4g}")
        zeros = int(np.sum(flat == 0))
        print(f"  {C.BOLD}Zeros:{C.RESET}   {zeros:,} ({100 * zeros / flat.size:.1f}%)")
        if nan_count > 0:
            print(f"  {C.BOLD}NaN:{C.RESET}     {nan_count:,} ({100 * nan_count / flat.size:.1f}%)")

    complete_stats = _complete_path

    def do_hist(self, arg):
        """Text histogram.  Usage: hist [-b BINS] <dataset>[slice]  (default 20 bins)"""
        parts = arg.split()
        bins = 20
        i = 0
        remaining = []
        while i < len(parts):
            if parts[i] == '-b' and i + 1 < len(parts):
                bins = int(parts[i + 1])
                i += 2
            else:
                remaining.append(parts[i])
                i += 1

        if not remaining:
            print("Usage: hist [-b BINS] <dataset>[slice]")
            return

        arg_str = ' '.join(remaining)
        name, sl = self._parse_name_slice(arg_str)
        if sl == 'ERROR':
            return

        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return
        if not _is_numeric(obj.dtype):
            print(f"{C.RED}Not numeric. Try 'unique' for categorical data.{C.RESET}")
            return

        total = int(np.prod(obj.shape)) if obj.shape else 1
        if sl is not None:
            data = obj[sl]
        elif total > 10_000_000:
            step = max(1, obj.shape[0] // 1_000_000)
            data = obj[::step]
            print(f"  {C.DIM}(sampled {data.size:,} of {total:,}){C.RESET}")
        else:
            data = obj[()]

        flat = np.asarray(data, dtype=np.float64).flatten()
        flat = flat[~np.isnan(flat)]

        if flat.size == 0:
            print("  (all NaN)")
            return

        counts, edges = np.histogram(flat, bins=bins)
        max_count = max(counts)
        tw = shutil.get_terminal_size((80, 24)).columns
        bar_width = max(10, min(40, tw - 35))

        for i in range(len(counts)):
            lo, hi = edges[i], edges[i + 1]
            bar_len = int(counts[i] / max_count * bar_width) if max_count > 0 else 0
            bar = '\u2588' * bar_len
            pct = 100 * counts[i] / flat.size
            print(f"  [{lo:>9.3g},{hi:>9.3g}) {C.GREEN}{bar}{C.RESET} {counts[i]:>7,} ({pct:4.1f}%)")

    complete_hist = _complete_path

    def do_unique(self, arg):
        """Show unique values.  Usage: unique <dataset>[slice]"""
        if not arg:
            print("Usage: unique <dataset>[slice]")
            return

        name, sl = self._parse_name_slice(arg)
        if sl == 'ERROR':
            return

        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return

        total = int(np.prod(obj.shape)) if obj.shape else 1
        if sl is not None:
            data = obj[sl]
        elif total > 10_000_000:
            print(f"{C.YELLOW}Dataset too large ({total:,}). Use a slice.{C.RESET}")
            return
        else:
            data = obj[()]

        flat = np.asarray(data).flatten()
        uniq, counts = np.unique(flat, return_counts=True)

        if len(uniq) > 50:
            print(f"  {len(uniq)} unique values (top 20 by frequency):")
            order = np.argsort(-counts)[:20]
        else:
            order = np.arange(len(uniq))

        for i in order:
            v = uniq[i]
            if isinstance(v, bytes):
                v = v.decode('utf-8', errors='replace')
            pct = 100 * counts[i] / len(flat)
            print(f"    {str(v):>20}  {counts[i]:>10,}  ({pct:5.1f}%)")

    complete_unique = _complete_path

    # ── Search & disk usage ──────────────────────────────────

    def do_find(self, arg):
        """Search by name pattern (regex).  Usage: find <pattern>"""
        if not arg:
            print("Usage: find <pattern>")
            return

        pattern = arg.strip()
        results = []

        def _visit(name, obj):
            if re.search(pattern, name, re.IGNORECASE):
                results.append((name, obj))

        self.file.visititems(_visit)

        if not results:
            print(f"  No matches for '{pattern}'")
            return

        for name, obj in results[:100]:
            if isinstance(obj, h5py.Group):
                print(f"  {C.BLUE}{C.BOLD}/{name}/{C.RESET}")
            else:
                shape_s = '\u00d7'.join(str(s) for s in obj.shape) if obj.shape else 'scalar'
                dt = 'string' if _is_string(obj.dtype) else str(obj.dtype)
                print(f"  {C.GREEN}/{name}{C.RESET}  {C.DIM}{shape_s} {dt}{C.RESET}")

        if len(results) > 100:
            print(f"  {C.YELLOW}... and {len(results) - 100} more{C.RESET}")

    def do_du(self, arg):
        """Disk usage summary.  Usage: du [path]"""
        path = arg.strip() if arg.strip() else '.'
        obj = self._get(path)
        if obj is None:
            print(f"{C.RED}Not found: {path}{C.RESET}")
            return

        if isinstance(obj, h5py.Dataset):
            print(f"  {format_size(obj.id.get_storage_size()):>10}  {obj.name}")
            return

        sizes = {}
        for name in sorted(obj.keys()):
            child = obj[name]
            if isinstance(child, h5py.Dataset):
                sizes[name] = child.id.get_storage_size()
            elif isinstance(child, h5py.Group):
                total = [0]
                def _accum(n, o, t=total):
                    if isinstance(o, h5py.Dataset):
                        t[0] += o.id.get_storage_size()
                child.visititems(_accum)
                sizes[name + '/'] = total[0]

        if not sizes:
            print(f"  {C.DIM}(empty){C.RESET}")
            return

        max_sz = max(sizes.values()) if sizes else 1
        for name, sz in sorted(sizes.items(), key=lambda x: -x[1]):
            bar_len = int(sz / max_sz * 20) if max_sz > 0 else 0
            bar = '\u2588' * bar_len
            is_grp = name.endswith('/')
            color = C.BLUE + C.BOLD if is_grp else C.GREEN
            print(f"  {format_size(sz):>10}  {color}{name}{C.RESET}  {C.DIM}{bar}{C.RESET}")

        grand_total = sum(sizes.values())
        print(f"  {'─' * 10}")
        print(f"  {format_size(grand_total):>10}  total")

    complete_du = _complete_path

    # ── Export ───────────────────────────────────────────────

    def do_export(self, arg):
        """Export dataset slice to file.  Usage: export <dataset>[slice] <output.npy|.csv|.tsv>"""
        parts = arg.rsplit(None, 1)
        if len(parts) < 2:
            print("Usage: export <dataset>[slice] <output.npy|.csv|.tsv>")
            return

        ds_arg, outfile = parts
        name, sl = self._parse_name_slice(ds_arg)
        if sl == 'ERROR':
            return

        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return

        data = obj[sl] if sl is not None else obj[()]
        data = np.asarray(data)

        outfile = os.path.expanduser(outfile)
        if outfile.endswith('.npy'):
            np.save(outfile, data)
        elif outfile.endswith('.csv'):
            if data.ndim <= 2:
                np.savetxt(outfile, data, delimiter=',', fmt='%g' if _is_numeric(data.dtype) else '%s')
            else:
                data_2d = data.reshape(-1, data.shape[-1]) if data.ndim > 2 else data
                np.savetxt(outfile, data_2d, delimiter=',', fmt='%g' if _is_numeric(data.dtype) else '%s')
        elif outfile.endswith('.tsv'):
            if data.ndim <= 2:
                np.savetxt(outfile, data, delimiter='\t', fmt='%g' if _is_numeric(data.dtype) else '%s')
            else:
                data_2d = data.reshape(-1, data.shape[-1]) if data.ndim > 2 else data
                np.savetxt(outfile, data_2d, delimiter='\t', fmt='%g' if _is_numeric(data.dtype) else '%s')
        else:
            print(f"{C.RED}Unknown extension. Use .npy, .csv, or .tsv{C.RESET}")
            return

        print(f"  Saved {data.shape} {data.dtype} -> {outfile}")

    complete_export = _complete_path

    # ── Terminal helpers (sixel / key reading) ────────────────

    def _read_key(self, fd):
        """Read a single keypress in raw/cbreak terminal mode."""
        ch = os.read(fd, 1)
        if ch == b'\x1b':
            if select.select([fd], [], [], 0.05)[0]:
                ch2 = os.read(fd, 1)
                if ch2 == b'[':
                    if select.select([fd], [], [], 0.05)[0]:
                        ch3 = os.read(fd, 1)
                        if ch3 == b'A': return 'UP'
                        if ch3 == b'B': return 'DOWN'
                        if ch3 == b'C': return 'RIGHT'
                        if ch3 == b'D': return 'LEFT'
                        while select.select([fd], [], [], 0.01)[0]:
                            os.read(fd, 1)
            return 'ESC'
        if ch == b'\r' or ch == b'\n':
            return 'ENTER'
        try:
            return ch.decode('ascii')
        except Exception:
            return ''

    def _read_line_esc(self, fd):
        """Read a line in cbreak mode; ESC cancels (returns None), Enter confirms."""
        buf = []
        w = sys.stdout.write
        while True:
            ch = os.read(fd, 1)
            if ch == b'\x1b':
                while select.select([fd], [], [], 0.03)[0]:
                    os.read(fd, 1)
                return None
            elif ch == b'\r' or ch == b'\n':
                w('\r\n')
                sys.stdout.flush()
                return ''.join(buf)
            elif ch in (b'\x7f', b'\x08'):
                if buf:
                    buf.pop()
                    w('\b \b')
                    sys.stdout.flush()
            elif ch == b'\x03':
                return None
            else:
                try:
                    c = ch.decode('ascii')
                    if c.isprintable():
                        buf.append(c)
                        w(c)
                        sys.stdout.flush()
                except Exception:
                    pass

    @staticmethod
    def _safe_addstr(win, y, x, s, attr=0):
        """addstr that silently clips to window bounds."""
        try:
            height, width = win.getmaxyx()
            if y < 0 or y >= height or x >= width:
                return
            max_len = width - x - 1
            if max_len <= 0:
                return
            win.addnstr(y, x, s, max_len, attr)
        except curses.error:
            pass

    # ── Sixel rendering ──────────────────────────────────────

    def _render_signal_pixels(self, vals, width, height, ymin=0, ymax=None):
        """Render 1D signal to pixel array (H x W, uint8: 0=bg, 1=signal, 2=axis)."""
        if len(vals) != width:
            resampled = np.interp(
                np.linspace(0, 1, width),
                np.linspace(0, 1, len(vals)), vals)
        else:
            resampled = np.asarray(vals, dtype=np.float64)
        if ymax is None:
            ymax = np.max(resampled) if len(resampled) > 0 else 1
        span_y = ymax - ymin
        if span_y <= 0:
            pixels = np.zeros((height, width), dtype=np.uint8)
        else:
            norm = np.clip((resampled - ymin) / span_y * height, 0, height).astype(np.int32)
            row_idx = np.arange(height)[:, np.newaxis]
            threshold = (height - norm)[np.newaxis, :]
            pixels = (row_idx >= threshold).astype(np.uint8)
        pixels[-1, :] = 2
        pixels[:, 0] = 2
        for frac in (0.25, 0.5, 0.75):
            y = int(height * (1 - frac))
            if 0 <= y < height:
                pixels[y, 0:4] = 2
        return pixels

    def _encode_sixel_signal(self, pixels):
        """Encode signal pixel array as sixel (0=bg, 1=signal, 2=axis)."""
        h, w = pixels.shape
        pad = (6 - h % 6) % 6
        if pad:
            pixels = np.vstack([np.zeros((pad, w), dtype=np.uint8), pixels])
            h += pad
        n_bands = h // 6
        parts = ['\033Pq']
        parts.append(f'"1;1;{w};{h}')
        if self.dark_bg:
            parts.append('#0;2;12;12;12')
            parts.append('#1;2;85;85;85')
            parts.append('#2;2;35;35;35')
        else:
            parts.append('#0;2;100;100;100')
            parts.append('#1;2;8;8;8')
            parts.append('#2;2;65;65;65')
        for band in range(n_bands):
            chunk = pixels[band * 6:band * 6 + 6, :]
            first = True
            for val in range(3):
                mask = (chunk == val)
                packed = np.zeros(w, dtype=np.uint8)
                for bit in range(6):
                    packed |= (mask[bit].astype(np.uint8) << bit)
                if not np.any(packed):
                    continue
                if not first:
                    parts.append('$')
                parts.append('#%d' % val)
                parts.append(self._sixel_rle(packed))
                first = False
            if band + 1 < n_bands:
                parts.append('-')
        parts.append('\033\\')
        return ''.join(parts)

    def _render_heatmap_pixels(self, data, width, height):
        """Render 2D data as heatmap pixel indices (H x W, uint8 0-63 viridis)."""
        nrows, ncols = data.shape
        vmin = np.nanmin(data)
        vmax = np.nanmax(data)
        if vmax == vmin:
            indices = np.full(data.shape, 32, dtype=np.uint8)
        else:
            indices = np.clip(
                ((data - vmin) / (vmax - vmin) * 63).astype(np.int32),
                0, 63).astype(np.uint8)
        # Scale to pixel dimensions
        row_scale = max(1, height // max(1, nrows))
        col_scale = max(1, width // max(1, ncols))
        pixel_indices = np.repeat(np.repeat(indices, row_scale, axis=0),
                                  col_scale, axis=1)
        return pixel_indices[:height, :width]

    def _encode_sixel_heatmap(self, pixel_indices):
        """Encode heatmap pixel indices (H x W, uint8 0-63) as sixel string."""
        h, w = pixel_indices.shape
        pad = (6 - h % 6) % 6
        if pad:
            pixel_indices = np.vstack([pixel_indices,
                                       np.full((pad, w), pixel_indices[-1, :].mean().astype(np.uint8),
                                               dtype=np.uint8)])
            h += pad
        n_bands = h // 6
        parts = ['\033Pq']
        parts.append(f'"1;1;{w};{h}')
        for i, (r, g, b) in enumerate(VIRIDIS_64):
            parts.append(f'#{i};2;{r*100//255};{g*100//255};{b*100//255}')
        for band in range(n_bands):
            chunk = pixel_indices[band * 6:band * 6 + 6, :]
            first = True
            present = np.unique(chunk)
            for val in present:
                mask = (chunk == val)
                packed = np.zeros(w, dtype=np.uint8)
                for bit in range(6):
                    packed |= (mask[bit].astype(np.uint8) << bit)
                if not np.any(packed):
                    continue
                if not first:
                    parts.append('$')
                parts.append(f'#{val}')
                parts.append(self._sixel_rle(packed))
                first = False
            if band + 1 < n_bands:
                parts.append('-')
        parts.append('\033\\')
        return ''.join(parts)

    @staticmethod
    def _sixel_rle(packed):
        """RLE-encode a row of sixel values."""
        chars = (packed + 0x3F).tobytes()
        if not chars:
            return ''
        result = []
        i = 0
        n = len(chars)
        while i < n:
            ch = chars[i]
            count = 1
            while i + count < n and chars[i + count] == ch and count < 255:
                count += 1
            if count >= 3:
                result.append(f'!{count}')
                result.append(chr(ch))
            else:
                result.append(chr(ch) * count)
            i += count
        return ''.join(result)

    # ── Visualization: plot ──────────────────────────────────

    def do_plot(self, arg):
        """Inline signal plot.  Usage: plot <dataset>[slice]

        Renders a bar chart sampled to terminal width.
        For 2D datasets, plots the mean across rows (or slice a single row).

        Examples:
            plot weights               Full dataset
            plot weights[0]            Single row from 2D
            plot data[::100]           Every 100th element
        """
        if not arg:
            print("Usage: plot <dataset>[slice]")
            return
        name, sl = self._parse_name_slice(arg)
        if sl == 'ERROR':
            return
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return
        if not _is_numeric(obj.dtype):
            print(f"{C.RED}plot requires numeric data{C.RESET}")
            return

        tw = shutil.get_terminal_size((80, 24)).columns
        th = shutil.get_terminal_size((80, 24)).lines
        plot_width = tw - 12
        height = min(15, th - 4)
        ndim = len(obj.shape)

        if sl is not None:
            data = np.asarray(obj[sl], dtype=np.float64).flatten()
        elif ndim == 1:
            step = max(1, obj.shape[0] // (plot_width * 4))
            data = obj[::step].astype(np.float64)
        elif ndim == 2:
            step = max(1, obj.shape[1] // (plot_width * 4))
            sampled = obj[:, ::step].astype(np.float64)
            data = np.nanmean(sampled, axis=0)
        else:
            print(f"{C.RED}plot supports 1D/2D (got {ndim}D). Use a slice.{C.RESET}")
            return

        data = np.nan_to_num(data, nan=0.0)
        if len(data) == 0:
            print("  (no data)")
            return

        # Bin to plot_width
        if len(data) > plot_width:
            binned = np.array_split(data, plot_width)
            vals = np.array([np.mean(b) for b in binned])
        elif len(data) < plot_width:
            vals = np.interp(np.linspace(0, 1, plot_width),
                             np.linspace(0, 1, len(data)), data)
        else:
            vals = data

        vmax = np.max(vals)
        vmin = np.min(vals)
        if vmax == 0 and vmin == 0:
            print("  (all zeros)")
            return
        if vmax <= vmin:
            vmax = vmin + 1

        norm = np.clip((vals - vmin) / (vmax - vmin) * height, 0, height)
        shape_s = '\u00d7'.join(str(s) for s in obj.shape)
        print(f"  {C.DIM}{obj.name}  {shape_s}  "
              f"range=[{vmin:.4g}, {vmax:.4g}]{C.RESET}")

        for row in range(height, 0, -1):
            chars = []
            for v in norm:
                if v >= row:
                    chars.append('\u2588')
                elif v > row - 1:
                    idx = min(8, max(1, int((v - (row - 1)) * 8)))
                    chars.append(BLOCKS[idx])
                else:
                    chars.append(' ')
            if row == height:
                label = f"{vmax:>8.2g} \u2502"
            elif row == 1:
                label = f"{vmin:>8.2g} \u2502"
            elif row == (height + 1) // 2:
                label = f"{(vmin + vmax) / 2:>8.2g} \u2502"
            else:
                label = f"{'':>8} \u2502"
            print(label + ''.join(chars))

    complete_plot = _complete_path

    # ── Visualization: browse ────────────────────────────────

    def do_browse(self, arg):
        """Interactive dataset browser.  Usage: browse <dataset>[slice]  (alias: b)

        1D: bar chart with pan/zoom along index axis.
        2D: heatmap (rows = tracks, columns = x-axis, color = value).

        Keys:
            h/l, Left/Right  Pan x 25%
            H/L              Pan x 50%
            k/j              Zoom x in/out 2x
            Up/Down          Scroll rows (2D only)
            1-8              Zoom presets
            g                Goto index (or row,col for 2D)
            s                Stats for visible region
            q / Esc          Quit
        """
        if not arg:
            print("Usage: browse <dataset>[slice]")
            return
        name, sl = self._parse_name_slice(arg)
        if sl == 'ERROR':
            return
        obj = self._get(name)
        if obj is None:
            print(f"{C.RED}Not found: {name}{C.RESET}")
            return
        if not isinstance(obj, h5py.Dataset):
            print(f"{C.RED}Not a dataset: {name}{C.RESET}")
            return
        if not _is_numeric(obj.dtype):
            print(f"{C.RED}browse requires numeric data{C.RESET}")
            return

        # If a slice is given, apply it to determine effective shape
        if sl is not None:
            # Determine shape without loading data
            try:
                test = obj[sl]
                effective_shape = np.asarray(test).shape
                effective_ndim = len(effective_shape)
            except Exception as e:
                print(f"{C.RED}Invalid slice: {e}{C.RESET}")
                return
            if effective_ndim == 0:
                print(f"  Scalar: {test}")
                return
            elif effective_ndim == 1:
                # Load the sliced data into memory and browse it
                data = np.asarray(test, dtype=np.float64)
                if self.sixel:
                    self._browse_1d_sixel_mem(data, name + str(sl))
                else:
                    curses.wrapper(self._browse_1d_curses_mem, data, name + str(sl))
                return
            elif effective_ndim == 2:
                data = np.asarray(test, dtype=np.float64)
                if self.sixel:
                    self._browse_2d_sixel_mem(data, name + str(sl))
                else:
                    curses.wrapper(self._browse_2d_curses_mem, data, name + str(sl))
                return
            else:
                print(f"{C.RED}browse supports 1D/2D (slice gave {effective_ndim}D).{C.RESET}")
                return

        ndim = len(obj.shape)
        if ndim == 1:
            if self.sixel:
                self._browse_1d_sixel(obj)
            else:
                curses.wrapper(self._browse_1d_curses, obj)
        elif ndim == 2:
            if self.sixel:
                self._browse_2d_sixel(obj)
            else:
                curses.wrapper(self._browse_2d_curses, obj)
        else:
            print(f"{C.RED}browse supports 1D/2D (got {ndim}D). Use a slice to reduce:{C.RESET}")
            print(f"  {C.DIM}browse {name}[0]     browse {name}[:, :, 0]{C.RESET}")

    def do_b(self, arg):
        """Alias for browse."""
        self.do_browse(arg)

    complete_browse = _complete_path
    complete_b = _complete_path

    # ── 1D Browse (sixel) ────────────────────────────────────

    def _browse_1d_sixel(self, ds):
        """Sixel browser for 1D h5py dataset."""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        total = ds.shape[0]
        col_start = 0
        col_span = total
        status_msg = ''
        DM, BO, RS = '\033[2m', '\033[1m', '\033[0m'

        try:
            tty.setcbreak(fd)
            sys.stdout.write('\033[?25l')
            sys.stdout.flush()

            while True:
                col_start = max(0, min(col_start, total - 10))
                col_end = min(col_start + col_span, total)
                col_span = col_end - col_start
                if col_span < 10:
                    col_span = min(10, total)
                    col_end = min(col_start + col_span, total)

                t_rows, t_cols, t_xpix, t_ypix = self._get_terminal_pixels()
                cell_w = max(1, t_xpix // t_cols)
                cell_h = max(1, t_ypix // t_rows)
                y_margin = 6
                text_lines = 4
                plot_px_w = max(100, (t_cols - y_margin) * cell_w)
                plot_px_h = max(50, (t_rows - text_lines) * cell_h)

                # Load data with stride subsampling
                step = max(1, col_span // plot_px_w)
                vals = ds[col_start:col_end:step].astype(np.float64)
                vals = np.nan_to_num(vals, nan=0.0)

                data_max = float(np.max(vals)) if len(vals) > 0 else 1
                data_min = float(np.min(vals)) if len(vals) > 0 else 0
                disp_ymin = min(0, data_min)
                disp_ymax = data_max if data_max > disp_ymin else disp_ymin + 1

                pixels = self._render_signal_pixels(vals, plot_px_w, plot_px_h,
                                                    ymin=disp_ymin, ymax=disp_ymax)
                sixel = self._encode_sixel_signal(pixels)

                w = sys.stdout.write
                w('\033[?2026h')
                w('\033[2J\033[H')
                w(f' {BO}{ds.name}{RS}  [{col_start:,}:{col_end:,}] of {total:,}'
                  f'  step={step}\r\n')
                w(f' {DM}max={data_max:.4g}  min={data_min:.4g}  '
                  f'mean={float(np.mean(vals)):.4g}{RS}\r\n')

                img_top = 3
                w(f'\033[{y_margin}C')
                w(sixel)

                sixel_rows = (plot_px_h + cell_h - 1) // cell_h
                w(f'\033[{img_top};1H{DM}{disp_ymax:>5.2f}{RS}')
                mid_row = img_top + sixel_rows // 2
                mid_val = (disp_ymin + disp_ymax) / 2
                w(f'\033[{mid_row};1H{DM}{mid_val:>5.2f}{RS}')
                w(f'\033[{img_top + sixel_rows - 1};1H{DM}{disp_ymin:>5.2f}{RS}')

                after_row = img_top + sixel_rows + 1
                w(f'\033[{after_row};1H')
                if status_msg:
                    w(f' {BO}{status_msg}{RS}')
                else:
                    w(f' {DM}h/l:pan  k/j:zoom  1-8:presets  g:goto  s:stats  q:quit{RS}')
                w('\033[?2026l')
                sys.stdout.flush()
                status_msg = ''

                key = self._read_key(fd)
                if key == 'q' or key == 'ESC':
                    break
                elif key in ('h', 'LEFT'):
                    shift = max(1, col_span // 4)
                    col_start -= shift
                elif key in ('l', 'RIGHT'):
                    shift = max(1, col_span // 4)
                    col_start += shift
                elif key == 'H':
                    col_start -= max(1, col_span // 2)
                elif key == 'L':
                    col_start += max(1, col_span // 2)
                elif key in ('k', 'UP'):
                    center = col_start + col_span // 2
                    col_span = max(10, col_span // 2)
                    col_start = center - col_span // 2
                elif key in ('j', 'DOWN'):
                    center = col_start + col_span // 2
                    col_span = min(total, col_span * 2)
                    col_start = center - col_span // 2
                elif key.isdigit() and '1' <= key <= '8':
                    presets = [100, 1000, 10_000, 100_000, 1_000_000,
                               10_000_000, 50_000_000, 100_000_000]
                    center = col_start + col_span // 2
                    col_span = min(total, presets[int(key) - 1])
                    col_start = center - col_span // 2
                elif key == 'g':
                    w('\r\n Goto index: ')
                    w('\033[?25h')
                    sys.stdout.flush()
                    result = self._read_line_esc(fd)
                    w('\033[?25l')
                    sys.stdout.flush()
                    if result:
                        try:
                            idx = int(result.replace(',', ''))
                            col_start = max(0, idx - col_span // 2)
                        except ValueError:
                            status_msg = f"Invalid: {result}"
                elif key == 's':
                    status_msg = (f"min={data_min:.4g}  max={data_max:.4g}  "
                                  f"mean={float(np.mean(vals)):.4g}  "
                                  f"std={float(np.std(vals)):.4g}")

        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            sys.stdout.write('\033[?25h\033[2J\033[H')
            sys.stdout.flush()

    def _browse_1d_sixel_mem(self, data, label):
        """Sixel browser for in-memory 1D array."""
        # Wrap in a simple namespace so it looks like a dataset
        class _MemDS:
            def __init__(self, arr, name):
                self.shape = arr.shape
                self.name = name
                self._arr = arr
            def __getitem__(self, key):
                return self._arr[key]
        self._browse_1d_sixel(_MemDS(data, label))

    # ── 1D Browse (curses) ───────────────────────────────────

    def _browse_1d_curses(self, stdscr, ds):
        """Curses browser for 1D h5py dataset."""
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, -1, -1)
        curses.init_pair(2, curses.COLOR_CYAN, -1)
        curses.init_pair(3, curses.COLOR_BLUE, -1)
        curses.curs_set(0)
        stdscr.keypad(True)

        total = ds.shape[0]
        col_start = 0
        col_span = total
        status_msg = ''

        while True:
            col_start = max(0, min(col_start, total - 10))
            col_end = min(col_start + col_span, total)
            col_span = col_end - col_start

            height, width = stdscr.getmaxyx()
            stdscr.erase()

            plot_width = width - 12
            plot_height = max(3, height - 6)
            if plot_width < 10:
                self._safe_addstr(stdscr, 0, 0, "Terminal too narrow")
                stdscr.refresh()
                key = stdscr.getch()
                if key == ord('q') or key == 27:
                    break
                continue

            step = max(1, col_span // plot_width)
            vals = ds[col_start:col_end:step].astype(np.float64)
            vals = np.nan_to_num(vals, nan=0.0)

            vmax = float(np.max(vals)) if len(vals) > 0 else 1
            vmean = float(np.mean(vals)) if len(vals) > 0 else 0
            if vmax <= 0:
                vmax = 1

            # Header
            header = f" {ds.name}  [{col_start:,}:{col_end:,}] of {total:,}"
            self._safe_addstr(stdscr, 0, 0, header, curses.A_BOLD)
            stats_line = f" max={vmax:.4g}  mean={vmean:.4g}  step={step}"
            self._safe_addstr(stdscr, 1, 0, stats_line, curses.color_pair(3))

            # Halfblock rendering
            SIG_ATTR = curses.color_pair(1) | curses.A_BOLD
            AXIS_ATTR = curses.color_pair(2)

            if len(vals) > plot_width:
                binned = np.array_split(vals, plot_width)
                pv = np.array([np.mean(b) for b in binned])
            elif len(vals) < plot_width:
                pv = np.interp(np.linspace(0, 1, plot_width),
                               np.linspace(0, 1, len(vals)), vals)
            else:
                pv = vals
            px_h = plot_height * 2
            norm = np.clip(pv / vmax * px_h, 0, px_h)

            for cr in range(plot_height):
                ry = 3 + cr
                if cr == 0:
                    label = f"{vmax:>8.2f} \u2502"
                elif cr == plot_height - 1:
                    label = f"{'0':>8} \u2502"
                elif cr == plot_height // 2:
                    label = f"{vmax / 2:>8.2f} \u2502"
                else:
                    label = f"{'':>8} \u2502"
                self._safe_addstr(stdscr, ry, 0, label, AXIS_ATTR)
                py_upper = (plot_height - 1 - cr) * 2 + 1
                py_lower = (plot_height - 1 - cr) * 2
                chars = []
                for v in norm[:plot_width]:
                    if v > py_upper:
                        chars.append('\u2588')
                    elif v > py_lower:
                        chars.append('\u2584')
                    else:
                        chars.append(' ')
                self._safe_addstr(stdscr, ry, 10, ''.join(chars), SIG_ATTR)

            # Help bar
            help_y = height - 1
            if status_msg:
                self._safe_addstr(stdscr, help_y, 0, f" {status_msg}",
                                  curses.color_pair(3) | curses.A_BOLD)
            else:
                self._safe_addstr(stdscr, help_y, 0,
                                  " h/l:pan  k/j:zoom  1-8:presets  g:goto  s:stats  q:quit",
                                  curses.A_DIM)
            stdscr.refresh()
            status_msg = ''

            key = stdscr.getch()
            if key == ord('q') or key == 27:
                break
            elif key == curses.KEY_LEFT or key == ord('h'):
                col_start -= max(1, col_span // 4)
            elif key == curses.KEY_RIGHT or key == ord('l'):
                col_start += max(1, col_span // 4)
            elif key == ord('H'):
                col_start -= max(1, col_span // 2)
            elif key == ord('L'):
                col_start += max(1, col_span // 2)
            elif key == curses.KEY_UP or key == ord('k'):
                center = col_start + col_span // 2
                col_span = max(10, col_span // 2)
                col_start = center - col_span // 2
            elif key == curses.KEY_DOWN or key == ord('j'):
                center = col_start + col_span // 2
                col_span = min(total, col_span * 2)
                col_start = center - col_span // 2
            elif ord('1') <= key <= ord('8'):
                presets = [100, 1000, 10_000, 100_000, 1_000_000,
                           10_000_000, 50_000_000, 100_000_000]
                center = col_start + col_span // 2
                col_span = min(total, presets[key - ord('1')])
                col_start = center - col_span // 2
            elif key == ord('s'):
                status_msg = (f"min={float(np.min(vals)):.4g}  max={vmax:.4g}  "
                              f"mean={vmean:.4g}  std={float(np.std(vals)):.4g}")
            elif key == curses.KEY_RESIZE:
                try:
                    curses.update_lines_cols()
                except AttributeError:
                    pass
                stdscr.clear()

    def _browse_1d_curses_mem(self, stdscr, data, label):
        """Curses browser for in-memory 1D array."""
        class _MemDS:
            def __init__(self, arr, name):
                self.shape = arr.shape
                self.name = name
                self._arr = arr
            def __getitem__(self, key):
                return self._arr[key]
        self._browse_1d_curses(stdscr, _MemDS(data, label))

    # ── 2D Browse (sixel heatmap) ────────────────────────────

    def _browse_2d_sixel(self, ds):
        """Sixel heatmap browser for 2D h5py dataset."""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        n_rows, n_cols = ds.shape
        col_start = 0
        col_span = n_cols
        row_start = 0
        status_msg = ''
        DM, BO, RS = '\033[2m', '\033[1m', '\033[0m'

        try:
            tty.setcbreak(fd)
            sys.stdout.write('\033[?25l')
            sys.stdout.flush()

            while True:
                col_start = max(0, col_start)
                col_end = min(col_start + col_span, n_cols)
                if col_end <= col_start:
                    col_start = max(0, n_cols - 10)
                    col_end = n_cols
                col_span = col_end - col_start

                t_rows, t_cols, t_xpix, t_ypix = self._get_terminal_pixels()
                cell_w = max(1, t_xpix // t_cols)
                cell_h = max(1, t_ypix // t_rows)
                y_margin = 7
                text_lines = 5
                plot_px_w = max(100, (t_cols - y_margin) * cell_w)
                plot_px_h = max(50, (t_rows - text_lines) * cell_h)

                # How many rows fit? Each data row gets at least 2px
                max_vis_rows = min(n_rows - row_start, plot_px_h // 2)
                max_vis_rows = max(1, max_vis_rows)
                row_end = min(row_start + max_vis_rows, n_rows)
                visible_rows = row_end - row_start

                # X subsampling
                x_step = max(1, col_span // plot_px_w)
                data = ds[row_start:row_end, col_start:col_end:x_step]
                data = np.asarray(data, dtype=np.float64)
                data = np.nan_to_num(data, nan=0.0)

                pixel_indices = self._render_heatmap_pixels(data, plot_px_w, plot_px_h)
                sixel = self._encode_sixel_heatmap(pixel_indices)

                vmin = float(np.min(data)) if data.size > 0 else 0
                vmax = float(np.max(data)) if data.size > 0 else 1

                w = sys.stdout.write
                w('\033[?2026h')
                w('\033[2J\033[H')
                w(f' {BO}{ds.name}{RS}  [{row_start}:{row_end}, '
                  f'{col_start}:{col_end}] of {n_rows}\u00d7{n_cols}'
                  f'  step={x_step}\r\n')
                w(f' {DM}range=[{vmin:.4g}, {vmax:.4g}]  '
                  f'mean={float(np.mean(data)):.4g}{RS}\r\n')

                # Colorbar legend
                cb_chars = min(32, t_cols - 30)
                cb = ''
                for ci in range(cb_chars):
                    idx = int(ci / cb_chars * 63)
                    r, g, b = VIRIDIS_64[idx]
                    cb += f'\033[48;2;{r};{g};{b}m '
                cb += '\033[0m'
                w(f' {DM}{vmin:.2g}{RS} {cb} {DM}{vmax:.2g}{RS}\r\n')

                img_top = 4
                w(f'\033[{y_margin}C')
                w(sixel)

                # Row labels
                sixel_rows = (plot_px_h + cell_h - 1) // cell_h
                label_count = min(6, visible_rows)
                for li in range(label_count):
                    frac = li / max(1, label_count - 1) if label_count > 1 else 0
                    ri = int(frac * (visible_rows - 1))
                    char_row = img_top + int(frac * (sixel_rows - 1))
                    w(f'\033[{char_row};1H{DM}{row_start + ri:>5}{RS}')

                after_row = img_top + sixel_rows + 1
                w(f'\033[{after_row};1H')
                if status_msg:
                    w(f' {BO}{status_msg}{RS}')
                else:
                    w(f' {DM}h/l:pan  k/j:zoom  \u2191/\u2193:scroll rows  '
                      f'g:goto  s:stats  q:quit{RS}')
                w('\033[?2026l')
                sys.stdout.flush()
                status_msg = ''

                key = self._read_key(fd)
                if key == 'q' or key == 'ESC':
                    break
                elif key in ('h', 'LEFT'):
                    col_start -= max(1, col_span // 4)
                elif key in ('l', 'RIGHT'):
                    col_start += max(1, col_span // 4)
                elif key == 'H':
                    col_start -= max(1, col_span // 2)
                elif key == 'L':
                    col_start += max(1, col_span // 2)
                elif key == 'k':
                    center = col_start + col_span // 2
                    col_span = max(10, col_span // 2)
                    col_start = center - col_span // 2
                elif key == 'j':
                    center = col_start + col_span // 2
                    col_span = min(n_cols, col_span * 2)
                    col_start = center - col_span // 2
                elif key == 'UP':
                    row_start = max(0, row_start - max(1, visible_rows // 4))
                elif key == 'DOWN':
                    row_start = min(max(0, n_rows - visible_rows),
                                    row_start + max(1, visible_rows // 4))
                elif key.isdigit() and '1' <= key <= '8':
                    presets = [100, 1000, 10_000, 100_000, 1_000_000,
                               10_000_000, 50_000_000, 100_000_000]
                    center = col_start + col_span // 2
                    col_span = min(n_cols, presets[int(key) - 1])
                    col_start = center - col_span // 2
                elif key == 'g':
                    w('\r\n Goto (col or row,col): ')
                    w('\033[?25h')
                    sys.stdout.flush()
                    result = self._read_line_esc(fd)
                    w('\033[?25l')
                    sys.stdout.flush()
                    if result:
                        try:
                            parts = result.replace(' ', '').split(',')
                            if len(parts) == 2:
                                row_start = int(parts[0])
                                col_start = int(parts[1]) - col_span // 2
                            else:
                                col_start = int(parts[0].replace(',', '')) - col_span // 2
                        except ValueError:
                            status_msg = f"Invalid: {result}"
                elif key == 's':
                    status_msg = (f"min={vmin:.4g}  max={vmax:.4g}  "
                                  f"mean={float(np.mean(data)):.4g}  "
                                  f"std={float(np.std(data)):.4g}")

        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            sys.stdout.write('\033[?25h\033[2J\033[H')
            sys.stdout.flush()

    def _browse_2d_sixel_mem(self, data, label):
        """Sixel heatmap browser for in-memory 2D array."""
        class _MemDS:
            def __init__(self, arr, name):
                self.shape = arr.shape
                self.name = name
                self._arr = arr
            def __getitem__(self, key):
                return self._arr[key]
        self._browse_2d_sixel(_MemDS(data, label))

    # ── 2D Browse (curses heatmap) ───────────────────────────

    def _browse_2d_curses(self, stdscr, ds):
        """Curses heatmap browser for 2D h5py dataset."""
        curses.start_color()
        curses.use_default_colors()
        curses.curs_set(0)
        stdscr.keypad(True)

        n_rows, n_cols = ds.shape
        col_start = 0
        col_span = n_cols
        row_start = 0
        status_msg = ''

        while True:
            col_start = max(0, col_start)
            col_end = min(col_start + col_span, n_cols)
            col_span = col_end - col_start

            height, width = stdscr.getmaxyx()
            stdscr.erase()

            plot_w = max(10, width - 8)
            plot_h = max(3, height - 5)

            visible_rows = min(n_rows - row_start, plot_h)
            row_end = row_start + visible_rows

            x_step = max(1, col_span // plot_w)
            data = ds[row_start:row_end, col_start:col_end:x_step]
            data = np.asarray(data, dtype=np.float64)
            data = np.nan_to_num(data, nan=0.0)

            vmin = float(np.min(data)) if data.size > 0 else 0
            vmax_d = float(np.max(data)) if data.size > 0 else 1
            if vmax_d <= vmin:
                vmax_d = vmin + 1

            header = (f" {ds.name}  [{row_start}:{row_end}, "
                      f"{col_start}:{col_end}] of {n_rows}\u00d7{n_cols}")
            self._safe_addstr(stdscr, 0, 0, header, curses.A_BOLD)
            stats_line = f" range=[{vmin:.3g}, {vmax_d:.3g}]  step={x_step}"
            self._safe_addstr(stdscr, 1, 0, stats_line, curses.A_DIM)

            # Render heatmap using ANSI 256-color via direct writes
            actual_cols = min(data.shape[1], plot_w)
            for ri in range(visible_rows):
                # Row label
                label = f"{row_start + ri:>5} "
                self._safe_addstr(stdscr, 3 + ri, 0, label, curses.A_DIM)
                row_data = data[ri, :actual_cols]
                indices = np.clip(
                    ((row_data - vmin) / (vmax_d - vmin) * 63).astype(np.int32),
                    0, 63)
                for ci in range(actual_cols):
                    color = VIRIDIS_ANSI[indices[ci]]
                    try:
                        stdscr.addstr(3 + ri, 7 + ci,
                                      ' ', curses.A_NORMAL)
                    except curses.error:
                        pass
            # We need to actually show colors — curses can't do 256-color easily.
            # Use a refresh + direct ANSI overlay approach.
            stdscr.refresh()

            # Overlay colored cells using direct ANSI escape codes
            for ri in range(visible_rows):
                row_data = data[ri, :actual_cols]
                indices = np.clip(
                    ((row_data - vmin) / (vmax_d - vmin) * 63).astype(np.int32),
                    0, 63)
                # Build colored line
                line_parts = []
                for ci in range(actual_cols):
                    color = VIRIDIS_ANSI[indices[ci]]
                    line_parts.append(f'\033[48;5;{color}m ')
                line_parts.append('\033[0m')
                sys.stdout.write(f'\033[{4 + ri};8H' + ''.join(line_parts))
            sys.stdout.flush()

            # Help bar
            help_y = height - 1
            if status_msg:
                self._safe_addstr(stdscr, help_y, 0, f" {status_msg}",
                                  curses.A_BOLD)
            else:
                self._safe_addstr(stdscr, help_y, 0,
                                  " h/l:pan  k/j:zoom  Up/Down:rows  g:goto  s:stats  q:quit",
                                  curses.A_DIM)
            stdscr.refresh()
            status_msg = ''

            key = stdscr.getch()
            if key == ord('q') or key == 27:
                break
            elif key == curses.KEY_LEFT or key == ord('h'):
                col_start -= max(1, col_span // 4)
            elif key == curses.KEY_RIGHT or key == ord('l'):
                col_start += max(1, col_span // 4)
            elif key == ord('H'):
                col_start -= max(1, col_span // 2)
            elif key == ord('L'):
                col_start += max(1, col_span // 2)
            elif key == ord('k'):
                center = col_start + col_span // 2
                col_span = max(10, col_span // 2)
                col_start = center - col_span // 2
            elif key == ord('j'):
                center = col_start + col_span // 2
                col_span = min(n_cols, col_span * 2)
                col_start = center - col_span // 2
            elif key == curses.KEY_UP:
                row_start = max(0, row_start - max(1, visible_rows // 4))
            elif key == curses.KEY_DOWN:
                row_start = min(max(0, n_rows - visible_rows),
                                row_start + max(1, visible_rows // 4))
            elif ord('1') <= key <= ord('8'):
                presets = [100, 1000, 10_000, 100_000, 1_000_000,
                           10_000_000, 50_000_000, 100_000_000]
                center = col_start + col_span // 2
                col_span = min(n_cols, presets[key - ord('1')])
                col_start = center - col_span // 2
            elif key == ord('s'):
                status_msg = (f"min={vmin:.4g}  max={vmax_d:.4g}  "
                              f"mean={float(np.mean(data)):.4g}  "
                              f"std={float(np.std(data)):.4g}")
            elif key == curses.KEY_RESIZE:
                try:
                    curses.update_lines_cols()
                except AttributeError:
                    pass
                stdscr.clear()

    def _browse_2d_curses_mem(self, stdscr, data, label):
        """Curses heatmap browser for in-memory 2D array."""
        class _MemDS:
            def __init__(self, arr, name):
                self.shape = arr.shape
                self.name = name
                self._arr = arr
            def __getitem__(self, key):
                return self._arr[key]
        self._browse_2d_curses(stdscr, _MemDS(data, label))

    # ── Utility ──────────────────────────────────────────────

    def do_help(self, arg):
        """Show help.  Usage: help [command]"""
        if arg:
            # Per-command help: use the docstring
            func = getattr(self, 'do_' + arg, None)
            if func and func.__doc__:
                print()
                print(func.__doc__)
                print()
            else:
                print(f"  Unknown command: {arg}")
            return

        print(f"""
{C.BOLD}Navigation{C.RESET}
  {C.GREEN}ls{C.RESET} [-l] [path]           List contents (-l for size/chunks/compression)
  {C.GREEN}ll{C.RESET} [path]                Alias for ls -l
  {C.GREEN}cd{C.RESET} <path>                Change group (supports {C.DIM}..  /  -{C.RESET})
  {C.GREEN}pwd{C.RESET}                      Print current path
  {C.GREEN}tree{C.RESET} [-d N] [path]       Recursive tree view (-d limits depth)

{C.BOLD}Data Viewing{C.RESET}  {C.DIM}(all support numpy-style slicing: ds[0:10, :5]){C.RESET}
  {C.GREEN}cat{C.RESET} <ds>[slice]           Print values  {C.DIM}cat weights[::100]  cat data[0]{C.RESET}
  {C.GREEN}head{C.RESET} [-n N] <ds>          First N rows (default 10)
  {C.GREEN}tail{C.RESET} [-n N] <ds>          Last N rows (default 10)
  {C.GREEN}peek{C.RESET} <ds>                 Smart preview (corners + range for large arrays)

{C.BOLD}Visualization{C.RESET}  {C.DIM}(performance-safe: only loads visible data via h5py stride slicing){C.RESET}
  {C.GREEN}browse{C.RESET} <ds>[slice]         Interactive browser (alias: {C.GREEN}b{C.RESET})
  {C.DIM}  1D: signal bar chart  |  2D: viridis heatmap (rows=tracks, cols=x-axis)
  Sixel pixel mode (auto-detected), curses text fallback
  h/l:pan  k/j:zoom  \u2191/\u2193:scroll rows(2D)  1-8:presets  g:goto  s:stats  q:quit{C.RESET}
  {C.GREEN}plot{C.RESET} <ds>[slice]            Inline sparkline bar chart (non-interactive)

{C.BOLD}Metadata{C.RESET}
  {C.GREEN}info{C.RESET} [name]               Full details (shape/dtype/chunks/compression/attrs)
  {C.GREEN}shape{C.RESET} <ds>                Dataset shape
  {C.GREEN}dtype{C.RESET} <ds>                Dataset dtype
  {C.GREEN}attrs{C.RESET} [name]              HDF5 attributes (default: current group)

{C.BOLD}Analysis{C.RESET}
  {C.GREEN}stats{C.RESET} <ds>[slice]          Min/max/mean/std/median/percentiles
  {C.GREEN}hist{C.RESET} [-b N] <ds>[slice]    Text histogram (default 20 bins)
  {C.GREEN}unique{C.RESET} <ds>[slice]         Unique values with counts

{C.BOLD}Search & Disk{C.RESET}
  {C.GREEN}find{C.RESET} <pattern>            Regex search across all paths
  {C.GREEN}du{C.RESET} [path]                 Disk usage per child with bars

{C.BOLD}Export{C.RESET}
  {C.GREEN}export{C.RESET} <ds>[slice] <file>  Save to .npy / .csv / .tsv

{C.BOLD}Tips{C.RESET}
  {C.DIM}Type a group name to cd into it, a dataset name to peek at it.
  Tab completion works for all paths.
  Use 'browse' (or 'b') for interactive visualization of 1D/2D datasets.
  Use help <command> for detailed usage.{C.RESET}
""")

    def do_exit(self, arg):
        """Exit h5sh."""
        return True

    def do_quit(self, arg):
        """Exit h5sh."""
        return True

    def do_q(self, arg):
        """Exit h5sh."""
        return True

    def do_EOF(self, arg):
        print()
        return True

    def emptyline(self):
        pass

    def default(self, line):
        """Smart default: typing a group name does cd, typing a dataset does peek."""
        name = line.strip()
        if not name:
            return

        obj = self._get(name)
        if obj is not None:
            if isinstance(obj, h5py.Group):
                self.do_cd(name)
            elif isinstance(obj, h5py.Dataset):
                self.do_peek(name)
        else:
            # Try with slice
            base, sl = self._parse_name_slice(name)
            if sl is not None and sl != 'ERROR':
                obj = self._get(base)
                if obj is not None and isinstance(obj, h5py.Dataset):
                    self.do_cat(name)
                    return
            print(f"Unknown command: {line}. Type 'help' for commands.")

    def postcmd(self, stop, line):
        return stop

    def close(self):
        self.file.close()


# ── Entry point ──────────────────────────────────────────────

def main():
    import argparse
    parser = argparse.ArgumentParser(
        description='h5sh - Interactive HDF5 file explorer',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            Interactive commands:
              ls [-l] [path]           list contents
              cd <path>                navigate groups
              tree [-d N] [path]       recursive listing
              cat <ds>[slice]          print data with numpy-style slicing
              head/tail [-n N] <ds>    first/last N rows
              peek <ds>                smart preview
              info <name>              full metadata
              stats <ds>               min/max/mean/std/percentiles
              hist <ds>                text histogram
              find <pattern>           regex search
              du [path]                disk usage
              export <ds>[sl] out.npy  save slice to file
        """),
    )
    parser.add_argument('file', help='HDF5 file to open')
    parser.add_argument('--no-color', action='store_true', help='Disable colors')
    parser.add_argument('-c', '--command', help='Run command and exit')
    parser.add_argument('-l', '--ls', action='store_true', help='List root (like h5ls)')
    parser.add_argument('-d', '--data', metavar='DATASET',
                        help='Print dataset (like h5ls -d)')

    args = parser.parse_args()

    if not os.path.isfile(args.file):
        print(f"Error: {args.file}: No such file", file=sys.stderr)
        sys.exit(1)

    shell = H5Shell(args.file, no_color=args.no_color)

    try:
        if args.ls:
            shell.do_ls('-l')
        elif args.data:
            shell.do_cat(args.data)
        elif args.command:
            for cmd_line in args.command.split(';'):
                shell.onecmd(cmd_line.strip())
        else:
            shell.cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted.")
    finally:
        shell.close()


if __name__ == '__main__':
    main()
