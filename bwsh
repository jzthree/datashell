#!/usr/bin/env python3
"""bwsh - Interactive bigWig file explorer.

Browse genomic signal tracks by chromosome and coordinate,
visualize signal in the terminal, compute region statistics.

Usage:
    bwsh signal.bw                  Interactive shell
    bwsh signal.bw -c 'view chr1:1000-2000'   Run command and exit
    bwsh signal.bw --chroms         List chromosomes
"""

import cmd
import sys
import os
import re
import shutil
import readline
import math
import curses
import termios
import tty
import select
import fcntl
import struct
import signal

try:
    import pyBigWig
except ImportError:
    print("bwsh requires pyBigWig: pip install pyBigWig", file=sys.stderr)
    sys.exit(1)

try:
    import numpy as np
except ImportError:
    print("bwsh requires numpy: pip install numpy", file=sys.stderr)
    sys.exit(1)


# ── Track wrapper ────────────────────────────────────────────

class Track:
    """One bigWig data source."""
    __slots__ = ('bw', 'filename', 'basename', 'chroms', 'index')

    def __init__(self, filename, index):
        self.filename = os.path.abspath(filename)
        self.basename = os.path.basename(filename)
        self.bw = pyBigWig.open(filename)
        self.chroms = self.bw.chroms()
        self.index = index

    def stats(self, chrom, start, end, **kw):
        if chrom not in self.chroms:
            return [0.0] * kw.get('nBins', 1)
        return self.bw.stats(chrom, start, end, **kw)

    def values(self, chrom, start, end):
        if chrom not in self.chroms:
            return [0.0] * (end - start)
        return self.bw.values(chrom, start, end)

    def close(self):
        self.bw.close()


def _union_chroms(tracks):
    """Union of all track chromosome dicts (max size on mismatch)."""
    merged = {}
    for t in tracks:
        for name, size in t.chroms.items():
            if name in merged:
                merged[name] = max(merged[name], size)
            else:
                merged[name] = size
    return merged


# ── ANSI colors ─────────────────────────────────────────────

class C:
    BLUE = '\033[34m'
    CYAN = '\033[36m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    RED = '\033[31m'
    MAGENTA = '\033[35m'
    DIM = '\033[2m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @classmethod
    def disable(cls):
        for attr in ('BLUE', 'CYAN', 'GREEN', 'YELLOW', 'RED',
                      'MAGENTA', 'DIM', 'BOLD', 'RESET'):
            setattr(cls, attr, '')


# ── Track colors ─────────────────────────────────────────────

TRACK_ANSI = [C.GREEN, C.CYAN, C.YELLOW, C.MAGENTA, C.RED, C.BLUE]
# Sixel RGB% per track: (dark_bg, light_bg)
TRACK_SIXEL = [
    ((45, 85, 45),  (15, 55, 15)),   # green
    ((40, 80, 90),  (10, 50, 65)),   # teal
    ((90, 75, 30),  (65, 50, 5)),    # amber
    ((75, 45, 80),  (55, 20, 60)),   # purple
    ((90, 45, 40),  (70, 20, 15)),   # red
    ((45, 55, 90),  (15, 25, 65)),   # blue
]
TRACK_CURSES_COLORS = [
    curses.COLOR_GREEN, curses.COLOR_CYAN, curses.COLOR_YELLOW,
    curses.COLOR_MAGENTA, curses.COLOR_RED, curses.COLOR_BLUE,
]


# ── Helpers ──────────────────────────────────────────────────

BLOCKS = ' \u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588'  # ▁▂▃▄▅▆▇█

def format_bp(n):
    """Format base pair count: 1234 -> '1,234 bp', 12345 -> '12.3 kb'."""
    if n < 1000:
        return f"{n} bp"
    elif n < 1_000_000:
        return f"{n/1000:.1f} kb"
    elif n < 1_000_000_000:
        return f"{n/1_000_000:.2f} Mb"
    else:
        return f"{n/1_000_000_000:.2f} Gb"


def format_pos(n):
    """Format position with commas: 1234567 -> '1,234,567'."""
    return f"{n:,}"


def format_size(nbytes):
    for unit in ('B', 'KB', 'MB', 'GB'):
        if abs(nbytes) < 1024:
            if nbytes == int(nbytes):
                return f"{int(nbytes)} {unit}"
            return f"{nbytes:.1f} {unit}"
        nbytes /= 1024
    return f"{nbytes:.1f} TB"


def parse_region(s, current_chrom=None, chrom_sizes=None):
    """Parse region string into (chrom, start, end).

    Supported formats:
        chr1                     whole chromosome
        chr1:1000-2000           standard
        chr1:1,000-2,000         with commas
        chr1:1000-2k             k/K/m/M suffixes
        1000-2000                uses current chrom
        1000                     single pos, +/- 500bp context
    """
    s = s.strip()

    # Remove commas from numbers
    s_clean = s.replace(',', '')

    def parse_num(x):
        """Parse number with optional k/m suffix."""
        x = x.strip().lower()
        if x.endswith('m') or x.endswith('mb'):
            return int(float(x.rstrip('mb')) * 1_000_000)
        elif x.endswith('k') or x.endswith('kb'):
            return int(float(x.rstrip('kb')) * 1_000)
        return int(x)

    # Format: chr:start-end
    m = re.match(r'^(\w+):(\S+)-(\S+)$', s_clean)
    if m:
        chrom = m.group(1)
        start = parse_num(m.group(2))
        end = parse_num(m.group(3))
        return chrom, start, end

    # Format: start-end (relative to current chrom)
    m = re.match(r'^(\S+)-(\S+)$', s_clean)
    if m and current_chrom:
        start = parse_num(m.group(1))
        end = parse_num(m.group(2))
        return current_chrom, start, end

    # Format: single number (center +/- 500)
    try:
        pos = parse_num(s_clean)
        if current_chrom:
            size = chrom_sizes.get(current_chrom, 1_000_000) if chrom_sizes else 1_000_000
            start = max(0, pos - 500)
            end = min(size, pos + 500)
            return current_chrom, start, end
    except ValueError:
        pass

    # Format: just a chromosome name
    if chrom_sizes and s_clean in chrom_sizes:
        return s_clean, 0, chrom_sizes[s_clean]

    # Try case-insensitive chrom match
    if chrom_sizes:
        for name in chrom_sizes:
            if name.lower() == s_clean.lower():
                return name, 0, chrom_sizes[name]

    return None, None, None


def sparkline(values, width=None):
    """Single-row sparkline from array of values."""
    if width is None:
        width = shutil.get_terminal_size((80, 24)).columns - 4

    vals = np.array(values, dtype=np.float64)
    vals = np.nan_to_num(vals, nan=0.0)

    # Bin to width
    if len(vals) > width:
        binned = np.array_split(vals, width)
        vals = np.array([np.mean(b) for b in binned])
    elif len(vals) == 0:
        return '(no data)'

    vmin, vmax = np.min(vals), np.max(vals)
    if vmax == vmin:
        return BLOCKS[4] * len(vals)

    norm = (vals - vmin) / (vmax - vmin)
    return ''.join(BLOCKS[min(8, max(0, int(v * 8)))] for v in norm)


def signal_plot(values, height=15, width=None, color=None):
    """Multi-row signal plot with zero-baseline. color: ANSI escape or None."""
    if width is None:
        tw = shutil.get_terminal_size((80, 24)).columns
        width = tw - 12  # leave room for y-axis

    vals = np.array(values, dtype=np.float64)
    vals = np.nan_to_num(vals, nan=0.0)

    # Bin to width
    if len(vals) > width:
        binned = np.array_split(vals, width)
        vals = np.array([np.mean(b) for b in binned])

    vmin = np.min(vals)
    vmax = np.max(vals)
    ylo = vmin
    yhi = vmax
    span = yhi - ylo
    if span == 0:
        return "  (all zeros in region)"

    # Normalize to height (0 = ylo, height = yhi)
    norm = (vals - ylo) / span * height
    zero_h = (0 - ylo) / span * height  # height from bottom where zero is

    lines = []
    for row in range(height, 0, -1):
        chars = []
        for v in norm:
            lo = min(v, zero_h)
            hi = max(v, zero_h)
            overlap = max(0.0, min(hi, row) - max(lo, row - 1))
            if overlap >= 1.0:
                chars.append('\u2588')
            elif overlap > 0:
                idx = min(8, max(1, int(overlap * 8)))
                chars.append(BLOCKS[idx])
            else:
                chars.append(' ')

        # Y-axis label
        y_val = ylo + (row / height) * span
        if row == height:
            label = f"{yhi:>8.3g} \u2502"
        elif row == 1:
            label = f"{ylo:>8.3g} \u2502"
        elif abs(row - zero_h) < 0.5 and ylo < 0:
            label = f"{'0':>8} \u2502"
        elif row == (height + 1) // 2:
            label = f"{y_val:>8.3g} \u2502"
        else:
            label = f"{'':>8} \u2502"

        bar = ''.join(chars)
        if color:
            bar = color + bar + '\033[0m'
        lines.append(label + bar)

    return '\n'.join(lines)


# ── Main shell ───────────────────────────────────────────────

class BWShell(cmd.Cmd):

    def __init__(self, filenames, no_color=False):
        super().__init__()
        if no_color or not sys.stdout.isatty():
            C.disable()

        if isinstance(filenames, str):
            filenames = [filenames]

        # ── Multi-track setup ──
        self.tracks = [Track(fn, i) for i, fn in enumerate(filenames)]
        self.n_tracks = len(self.tracks)

        # Backward compat aliases (primary track)
        self.bw = self.tracks[0].bw
        self.filename = self.tracks[0].filename
        self.basename = self.tracks[0].basename

        # Union of all chroms
        self.chroms = _union_chroms(self.tracks)

        self.chrom = None
        self.region = None
        self.nan_zero = True
        self.dark_bg = self._detect_dark_bg()
        self.sixel = self._detect_sixel()
        self.ymin = [None] * self.n_tracks
        self.ymax = [None] * self.n_tracks
        self._update_prompt()

        readline.set_completer_delims(' \t\n')

        total_bp = sum(self.chroms.values())
        if self.n_tracks == 1:
            fsize = format_size(os.path.getsize(filenames[0]))
            self.intro = (
                f"\n{C.BOLD}bwsh{C.RESET} - {C.CYAN}{self.basename}{C.RESET}"
                f"  ({fsize}, {len(self.chroms)} chroms, {format_bp(total_bp)})\n"
                f"Type {C.GREEN}help{C.RESET} for commands, "
                f"{C.GREEN}chroms{C.RESET} to list chromosomes, "
                f"{C.GREEN}q{C.RESET} to quit.\n"
            )
        else:
            tlist = ', '.join(
                f"{TRACK_ANSI[i % len(TRACK_ANSI)]}{t.basename}{C.RESET}"
                for i, t in enumerate(self.tracks))
            self.intro = (
                f"\n{C.BOLD}bwsh{C.RESET} - {self.n_tracks} tracks: {tlist}\n"
                f"  ({len(self.chroms)} chroms, {format_bp(total_bp)})\n"
                f"Type {C.GREEN}help{C.RESET} for commands, "
                f"{C.GREEN}q{C.RESET} to quit.\n"
            )

    @staticmethod
    def _detect_dark_bg():
        """Guess if terminal has dark background."""
        fg_bg = os.environ.get('COLORFGBG', '')
        if fg_bg:
            try:
                bg = int(fg_bg.split(';')[-1])
                return bg < 8
            except Exception:
                pass
        return False  # default: light bg

    @staticmethod
    def _detect_sixel():
        """Detect sixel support via DA1 terminal query."""
        fd = sys.stdin.fileno()
        if not os.isatty(fd):
            return False
        old = termios.tcgetattr(fd)
        try:
            tty.setcbreak(fd)
            sys.stdout.write('\033[c')
            sys.stdout.flush()
            buf = []
            while select.select([fd], [], [], 0.5)[0]:
                ch = os.read(fd, 1)
                buf.append(ch)
                if ch == b'c':
                    break
            resp = b''.join(buf).decode('ascii', errors='ignore')
            if '?' in resp:
                params = resp.split('?')[-1].rstrip('c').split(';')
                return '4' in params
        except Exception:
            pass
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)
        return False

    def _update_prompt(self):
        if self.chrom:
            self.prompt = f"{C.BOLD}bwsh{C.RESET}:{C.BLUE}{self.chrom}{C.RESET}> "
        else:
            self.prompt = f"{C.BOLD}bwsh{C.RESET}> "

    def _parse(self, arg):
        """Parse region argument, returns (chrom, start, end) or None tuple."""
        if not arg.strip():
            if self.region:
                return self.region
            if self.chrom:
                return self.chrom, 0, self.chroms[self.chrom]
            return None, None, None
        return parse_region(arg, self.chrom, self.chroms)

    # ── Per-track data fetching ─────────────────────────────

    def _apply_nan_zero_track(self, track, chrom, start, end, nbins):
        """Fetch binned mean for a track, optionally coverage-scaled."""
        means = track.stats(chrom, start, end, type="mean", nBins=nbins)
        arr = np.nan_to_num(np.array(means, dtype=np.float64), nan=0.0)
        if self.nan_zero:
            cov = track.stats(chrom, start, end, type="coverage", nBins=nbins)
            cov_arr = np.nan_to_num(np.array(cov, dtype=np.float64), nan=0.0)
            arr *= cov_arr
        return arr

    def _get_values_track(self, track, chrom, start, end):
        """Get signal values for a track."""
        span = end - start
        tw = shutil.get_terminal_size((80, 24)).columns
        if span <= 10_000:
            vals = track.values(chrom, start, end)
            return np.nan_to_num(np.array(vals, dtype=np.float64), nan=0.0)
        else:
            nbins = min(span, max(tw * 2, 1000))
            return self._apply_nan_zero_track(track, chrom, start, end, nbins)

    def _get_values_exact_track(self, track, chrom, start, end, nbins=None):
        """Get exact binned values for a track."""
        if nbins:
            return self._apply_nan_zero_track(track, chrom, start, end, nbins)
        else:
            vals = track.values(chrom, start, end)
            return np.nan_to_num(np.array(vals, dtype=np.float64), nan=0.0)

    # Backward-compat wrappers (delegate to primary track)
    def _apply_nan_zero(self, chrom, start, end, nbins):
        return self._apply_nan_zero_track(self.tracks[0], chrom, start, end, nbins)

    def _get_values(self, chrom, start, end):
        return self._get_values_track(self.tracks[0], chrom, start, end)

    def _get_values_exact(self, chrom, start, end, nbins=None):
        return self._get_values_exact_track(self.tracks[0], chrom, start, end, nbins=nbins)

    def _complete_chrom(self, text, line, begidx, endidx):
        """Tab-complete chromosome names."""
        return [c for c in self.chroms if c.lower().startswith(text.lower())]

    def _set_region(self, chrom, start, end):
        """Update current region (for pan/zoom)."""
        self.region = (chrom, start, end)
        if self.chrom != chrom:
            self.chrom = chrom
            self._update_prompt()

    # ── Navigation ───────────────────────────────────────────

    def do_chroms(self, arg):
        """List chromosomes with sizes.  Usage: chroms [-a]
        -a  show all (including tiny scaffolds)"""
        show_all = '-a' in arg

        items = sorted(self.chroms.items(),
                       key=lambda x: -x[1])

        if not show_all:
            # Filter: only show chroms > 1% of largest, or named chr*
            largest = items[0][1] if items else 0
            threshold = largest * 0.001
            filtered = [(n, s) for n, s in items
                        if s >= threshold or n.startswith('chr')]
            if len(filtered) < len(items):
                hidden = len(items) - len(filtered)
                items_show = filtered
            else:
                hidden = 0
                items_show = items
        else:
            items_show = items
            hidden = 0

        max_name = max(len(n) for n, _ in items_show) if items_show else 5
        max_size = items_show[0][1] if items_show else 1
        bar_width = min(30, shutil.get_terminal_size((80, 24)).columns - max_name - 20)

        for name, size in items_show:
            bar_len = int(size / max_size * bar_width) if max_size > 0 else 0
            bar = '\u2588' * bar_len
            current = ' *' if name == self.chrom else ''
            # Track presence indicators for multi-track
            presence = ''
            if self.n_tracks > 1:
                for ti, tr in enumerate(self.tracks):
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    if name in tr.chroms:
                        presence += f'{tc}\u2588{C.RESET}'
                    else:
                        presence += f'{C.DIM}\u00b7{C.RESET}'
                presence += ' '
            print(f"  {presence}{C.GREEN}{name:<{max_name}}{C.RESET}  "
                  f"{format_bp(size):>12}  {C.DIM}{bar}{C.RESET}{C.YELLOW}{current}{C.RESET}")

        if hidden:
            print(f"  {C.DIM}... {hidden} small scaffolds hidden (use chroms -a){C.RESET}")

    def do_ls(self, arg):
        """Alias for chroms."""
        self.do_chroms(arg)

    def do_cd(self, arg):
        """Set current chromosome.  Usage: cd <chrom>  (cd - to go back)"""
        if not arg.strip():
            self.chrom = None
            self.region = None
            self._update_prompt()
            return

        name = arg.strip()
        if name in self.chroms:
            self.chrom = name
            self.region = None
            self._update_prompt()
        else:
            # Case-insensitive search
            for c in self.chroms:
                if c.lower() == name.lower():
                    self.chrom = c
                    self.region = None
                    self._update_prompt()
                    return
            print(f"{C.RED}Unknown chromosome: {name}{C.RESET}")

    complete_cd = _complete_chrom

    def do_pwd(self, arg):
        """Print current chromosome and last viewed region."""
        if self.region:
            chrom, start, end = self.region
            print(f"{chrom}:{format_pos(start)}-{format_pos(end)} ({format_bp(end - start)})")
        elif self.chrom:
            print(f"{self.chrom} ({format_bp(self.chroms[self.chrom])})")
        else:
            print("(no chromosome selected)")

    # ── Data viewing ─────────────────────────────────────────

    def do_view(self, arg):
        """ASCII signal plot.  Usage: view <region> [-h HEIGHT]

        Examples:
            view chr1:1000-2000        view chr1:1m-1.1m
            view 5000-6000             (uses current chrom)
            view                       (re-view last region)
            view chr1:1000-2000 -h 20  (taller plot)
        """
        height = 15
        parts = arg.split()
        if '-h' in parts:
            idx = parts.index('-h')
            if idx + 1 < len(parts):
                height = int(parts[idx + 1])
                parts = parts[:idx] + parts[idx + 2:]
        region_arg = ' '.join(parts)

        chrom, start, end = self._parse(region_arg)
        if chrom is None:
            print(f"{C.RED}Cannot parse region. Usage: view chr1:1000-2000{C.RESET}")
            return
        if chrom not in self.chroms:
            print(f"{C.RED}Unknown chromosome: {chrom}{C.RESET}")
            return

        size = self.chroms[chrom]
        start = max(0, start)
        end = min(size, end)
        span = end - start

        if span <= 0:
            print(f"{C.RED}Invalid region: start >= end{C.RESET}")
            return

        self._set_region(chrom, start, end)

        tw = shutil.get_terminal_size((80, 24)).columns
        plot_width = tw - 12

        # Get binned values for plotting
        nbins = min(span, plot_width)
        per_track_h = max(5, height // self.n_tracks)

        for ti, tr in enumerate(self.tracks):
            vals = self._get_values_exact_track(tr, chrom, start, end, nbins=nbins)
            vmax = np.max(vals)
            vmean = np.mean(vals)
            nonzero_frac = np.sum(vals > 0) / len(vals) * 100

            if self.n_tracks > 1:
                tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                label = f" {tc}{tr.basename}{C.RESET}"
            else:
                label = ""

            if ti == 0:
                print(f"\n  {C.BOLD}{chrom}:{format_pos(start)}-{format_pos(end)}{C.RESET}"
                      f"  ({format_bp(span)}){label}"
                      f"  {C.DIM}max={vmax:.2f}  mean={vmean:.2f}  "
                      f"coverage={nonzero_frac:.0f}%{C.RESET}\n")
            else:
                print(f"  {label}"
                      f"  {C.DIM}max={vmax:.2f}  mean={vmean:.2f}  "
                      f"coverage={nonzero_frac:.0f}%{C.RESET}\n")

            if vmax == 0 and np.min(vals) == 0:
                print(f"  {C.DIM}(no signal in region){C.RESET}")
            else:
                color = TRACK_ANSI[ti % len(TRACK_ANSI)] if self.n_tracks > 1 else None
                print(signal_plot(vals, height=per_track_h, width=plot_width, color=color))

        # X-axis
        axis = f"{'':>8} \u2514" + '\u2500' * min(len(vals), plot_width) + '\u2518'
        print(axis)
        # Position labels
        left_label = format_pos(start)
        right_label = format_pos(end)
        mid_label = format_pos((start + end) // 2)
        pad = min(len(vals), plot_width)
        spacing = pad - len(left_label) - len(right_label)
        if spacing > len(mid_label) + 4:
            mid_pos = pad // 2 - len(mid_label) // 2
            label_line = left_label + ' ' * (mid_pos - len(left_label)) + mid_label
            label_line += ' ' * (pad - len(label_line) - len(right_label)) + right_label
        else:
            label_line = left_label + ' ' * max(1, spacing) + right_label
        print(f"{'':>9} {label_line}")
        print()

    complete_view = _complete_chrom

    def do_cat(self, arg):
        """Print raw values.  Usage: cat <region>

        Examples:
            cat chr1:1000-1020     Per-base values
            cat chr1:1000-2000     Warns if region too large
        """
        chrom, start, end = self._parse(arg)
        if chrom is None:
            print(f"{C.RED}Cannot parse region. Usage: cat chr1:1000-2000{C.RESET}")
            return
        if chrom not in self.chroms:
            print(f"{C.RED}Unknown chromosome: {chrom}{C.RESET}")
            return

        size = self.chroms[chrom]
        start = max(0, start)
        end = min(size, end)
        span = end - start

        if span > 10_000:
            print(f"{C.YELLOW}Region is {format_bp(span)} ({span:,} values). "
                  f"Use a smaller slice or 'view' for visualization.{C.RESET}")
            print(f"  {C.DIM}cat {chrom}:{format_pos(start)}-{format_pos(start + 100)}{C.RESET}")
            return

        self._set_region(chrom, start, end)

        # Fetch per-track values
        all_vals = []
        for tr in self.tracks:
            v = tr.values(chrom, start, end)
            all_vals.append(np.nan_to_num(np.array(v, dtype=np.float64), nan=0.0))

        print(f"{C.DIM}{chrom}:{format_pos(start)}-{format_pos(end)} "
              f"({format_bp(span)}){C.RESET}")

        # Header for multi-track
        if self.n_tracks > 1:
            hdr = f"  {'pos':>12}"
            for tr in self.tracks:
                hdr += f"  {tr.basename:>12}"
            print(f"{C.DIM}{hdr}{C.RESET}")

        for i in range(span):
            pos = start + i
            line = f"  {format_pos(pos):>12}"
            all_zero = True
            for ti in range(self.n_tracks):
                v = all_vals[ti][i]
                if v != 0:
                    all_zero = False
                line += f"  {v:>12.4f}"
            if all_zero:
                print(f"{C.DIM}{line}{C.RESET}")
            else:
                print(line)

    complete_cat = _complete_chrom

    def do_head(self, arg):
        """First N bp of signal.  Usage: head [-n N] [chrom|region]  (default N=20)"""
        n = 20
        parts = arg.split()
        if '-n' in parts:
            idx = parts.index('-n')
            if idx + 1 < len(parts):
                n = int(parts[idx + 1])
                parts = parts[:idx] + parts[idx + 2:]

        region_arg = ' '.join(parts) if parts else ''

        if region_arg and region_arg in self.chroms:
            chrom = region_arg
            start, end = 0, n
        elif region_arg:
            chrom, start, end = self._parse(region_arg)
            if chrom is None:
                print(f"{C.RED}Cannot parse. Usage: head [-n N] <chrom>{C.RESET}")
                return
            end = start + n
        elif self.chrom:
            chrom = self.chrom
            start, end = 0, n
        else:
            print("No chromosome selected. Usage: head [-n N] <chrom>")
            return

        size = self.chroms.get(chrom, 0)
        end = min(end, size)
        self._set_region(chrom, start, end)

        all_vals = []
        for tr in self.tracks:
            v = tr.values(chrom, start, end)
            all_vals.append(np.nan_to_num(np.array(v, dtype=np.float64), nan=0.0))

        print(f"{C.DIM}{chrom}:{format_pos(start)}-{format_pos(end)}{C.RESET}")
        if self.n_tracks > 1:
            hdr = f"  {'pos':>12}"
            for tr in self.tracks:
                hdr += f"  {tr.basename:>12}"
            print(f"{C.DIM}{hdr}{C.RESET}")

        for i in range(end - start):
            pos = start + i
            line = f"  {format_pos(pos):>12}"
            for ti in range(self.n_tracks):
                line += f"  {all_vals[ti][i]:>12.4f}"
            print(line)

    complete_head = _complete_chrom

    def do_tail(self, arg):
        """Last N bp of signal.  Usage: tail [-n N] [chrom]  (default N=20)"""
        n = 20
        parts = arg.split()
        if '-n' in parts:
            idx = parts.index('-n')
            if idx + 1 < len(parts):
                n = int(parts[idx + 1])
                parts = parts[:idx] + parts[idx + 2:]

        chrom_arg = parts[0] if parts else None

        if chrom_arg and chrom_arg in self.chroms:
            chrom = chrom_arg
        elif self.chrom:
            chrom = self.chrom
        else:
            print("No chromosome selected. Usage: tail [-n N] <chrom>")
            return

        size = self.chroms[chrom]
        start = max(0, size - n)
        end = size
        self._set_region(chrom, start, end)

        all_vals = []
        for tr in self.tracks:
            v = tr.values(chrom, start, end)
            all_vals.append(np.nan_to_num(np.array(v, dtype=np.float64), nan=0.0))

        print(f"{C.DIM}{chrom}:{format_pos(start)}-{format_pos(end)}{C.RESET}")
        if self.n_tracks > 1:
            hdr = f"  {'pos':>12}"
            for tr in self.tracks:
                hdr += f"  {tr.basename:>12}"
            print(f"{C.DIM}{hdr}{C.RESET}")

        for i in range(end - start):
            pos = start + i
            line = f"  {format_pos(pos):>12}"
            for ti in range(self.n_tracks):
                line += f"  {all_vals[ti][i]:>12.4f}"
            print(line)

    complete_tail = _complete_chrom

    def do_peek(self, arg):
        """Whole-chromosome sparkline overview.  Usage: peek [chrom]"""
        if arg.strip() and arg.strip() in self.chroms:
            chrom = arg.strip()
        elif self.chrom:
            chrom = self.chrom
        else:
            print("No chromosome selected. Usage: peek <chrom>")
            return

        size = self.chroms[chrom]
        tw = shutil.get_terminal_size((80, 24)).columns
        nbins = tw - 4

        for ti, tr in enumerate(self.tracks):
            if chrom not in tr.chroms:
                if self.n_tracks > 1:
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    print(f"  {tc}{tr.basename}{C.RESET}  {C.DIM}(no {chrom}){C.RESET}")
                continue
            stats_mean = tr.bw.stats(chrom, 0, size, type="mean", nBins=nbins)
            stats_max_val = tr.bw.stats(chrom, 0, size, type="max", nBins=nbins)
            vals = np.nan_to_num(np.array(stats_mean, dtype=np.float64), nan=0.0)
            vals_max = np.nan_to_num(np.array(stats_max_val, dtype=np.float64), nan=0.0)

            overall_max = np.max(vals_max) if len(vals_max) > 0 else 0
            overall_mean = np.mean(vals[vals > 0]) if np.any(vals > 0) else 0
            coverage = np.sum(vals > 0) / len(vals) * 100

            tc = TRACK_ANSI[ti % len(TRACK_ANSI)] if self.n_tracks > 1 else ''
            label = f" {tc}{tr.basename}{C.RESET}" if self.n_tracks > 1 else ""

            print(f"\n  {C.BOLD}{chrom}{C.RESET}  {format_bp(size)}{label}"
                  f"  {C.DIM}max={overall_max:.2f}  mean(nonzero)={overall_mean:.2f}"
                  f"  coverage={coverage:.0f}%{C.RESET}")
            sc = tc if tc else C.GREEN
            print(f"  {sc}{sparkline(vals, width=nbins)}{C.RESET}")
            if ti == self.n_tracks - 1 or self.n_tracks == 1:
                print(f"  {C.DIM}{format_pos(0)}{' ' * (nbins - len(format_pos(0)) - len(format_pos(size)))}"
                      f"{format_pos(size)}{C.RESET}")
        print()

    complete_peek = _complete_chrom

    # ── Pan & Zoom ───────────────────────────────────────────

    def _pan(self, fraction):
        """Pan current view by fraction of span."""
        if not self.region:
            print(f"{C.DIM}No active region. Use 'view' first.{C.RESET}")
            return
        chrom, start, end = self.region
        span = end - start
        shift = int(span * fraction)
        size = self.chroms[chrom]
        new_start = max(0, start + shift)
        new_end = min(size, new_start + span)
        new_start = max(0, new_end - span)
        self.do_view(f"{chrom}:{new_start}-{new_end}")

    def _zoom(self, factor):
        """Zoom by factor (>1 = zoom out, <1 = zoom in)."""
        if not self.region:
            print(f"{C.DIM}No active region. Use 'view' first.{C.RESET}")
            return
        chrom, start, end = self.region
        span = end - start
        center = (start + end) // 2
        new_span = max(20, int(span * factor))
        size = self.chroms[chrom]
        new_start = max(0, center - new_span // 2)
        new_end = min(size, new_start + new_span)
        new_start = max(0, new_end - new_span)
        self.do_view(f"{chrom}:{new_start}-{new_end}")

    def do_left(self, arg):
        """Pan left 25%.  Usage: left [FRACTION]"""
        frac = float(arg) if arg.strip() else 0.25
        self._pan(-frac)

    def do_right(self, arg):
        """Pan right 25%.  Usage: right [FRACTION]"""
        frac = float(arg) if arg.strip() else 0.25
        self._pan(frac)

    def do_zoomin(self, arg):
        """Zoom in 2x.  Usage: zoomin [FACTOR]"""
        factor = float(arg) if arg.strip() else 0.5
        self._zoom(factor)

    def do_zi(self, arg):
        """Alias for zoomin."""
        self.do_zoomin(arg)

    def do_zoomout(self, arg):
        """Zoom out 2x.  Usage: zoomout [FACTOR]"""
        factor = float(arg) if arg.strip() else 2.0
        self._zoom(factor)

    def do_zo(self, arg):
        """Alias for zoomout."""
        self.do_zoomout(arg)

    # ── Interactive browser (curses) ─────────────────────────

    def do_browse(self, arg):
        """Interactive genome browser.  Usage: browse [region]

        Auto-detects sixel support. Uses pixel mode if available,
        otherwise falls back to curses text mode.

        Keys:
            \u2190/\u2192 or h/l   Pan 25%
            H/L           Pan 50%
            \u2191/\u2193 or k/j   Zoom in/out 2\u00d7
            1-8           Zoom to preset (1=100bp .. 8=100Mb)
            g             Goto coordinate / region
            c             Change chromosome
            n             Toggle NaN mode (mean / nanmean)
            t             Toggle light/dark theme (sixel only)
            s             Print stats to status line
            q / Esc       Exit browser
        """
        if self.sixel:
            self.do_bp(arg)
        else:
            self.do_bc(arg)

    complete_browse = _complete_chrom

    def do_b(self, arg):
        """Alias for browse."""
        self.do_browse(arg)

    def do_bc(self, arg):
        """Curses text-mode browser (fallback).  Usage: bc [region]

        Use this if your terminal does not support sixel graphics.
        Keys: same as browse, plus r to cycle render modes.
        """
        chrom, start, end = self._parse(arg)
        if chrom is None:
            if self.chrom:
                chrom = self.chrom
                start, end = 0, self.chroms[chrom]
            else:
                chrom = sorted(self.chroms.keys())[0]
                start, end = 0, self.chroms[chrom]

        size = self.chroms.get(chrom, 0)
        start = max(0, start)
        end = min(size, end)

        try:
            curses.wrapper(self._browse_loop, chrom, start, end)
        except Exception as e:
            print(f"Browser error: {e}")

    complete_b = _complete_chrom

    def _browse_loop(self, stdscr, chrom, start, end):
        """Main curses event loop for interactive browsing."""
        curses.start_color()
        curses.use_default_colors()
        # All colors use -1 (default fg/bg) so they adapt to light/dark themes
        curses.init_pair(1, -1, -1)                    # signal (default fg = adapts)
        curses.init_pair(2, curses.COLOR_CYAN, -1)     # axes/chrome
        curses.init_pair(3, curses.COLOR_BLUE, -1)     # stats (blue works on both themes)
        curses.init_pair(4, -1, -1)                    # text
        curses.init_pair(5, curses.COLOR_RED, -1)      # highlight

        # Per-track signal colors (pairs 10+)
        for i, tc in enumerate(TRACK_CURSES_COLORS):
            curses.init_pair(10 + i, tc, -1)

        curses.curs_set(0)
        stdscr.keypad(True)
        stdscr.timeout(-1)

        try:
            curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        except:
            pass

        status_msg = ""
        # Render modes: 'halfblock' (solid bars, 2x vert), 'block' (classic),
        #               'braille' (dot matrix, 2x horiz + 4x vert)
        render_mode = 'halfblock'
        RENDER_MODES = ['halfblock', 'block', 'braille']

        ZOOM_PRESETS = [100, 1_000, 10_000, 100_000, 1_000_000,
                        10_000_000, 50_000_000, 100_000_000]

        while True:
            size = self.chroms[chrom]
            start = max(0, min(start, size - 100))
            end = max(start + 20, min(end, size))
            span = end - start

            self._browse_draw(stdscr, chrom, start, end, status_msg,
                              render_mode=render_mode)
            status_msg = ""

            key = stdscr.getch()

            if key == curses.KEY_RESIZE:
                # Debounce: drain queued resize events, wait for settle
                stdscr.timeout(50)
                while stdscr.getch() != -1:
                    pass
                stdscr.timeout(-1)
                # Use actual OS size (curses internal may be stale)
                actual = shutil.get_terminal_size()
                curses.resizeterm(actual.lines, actual.columns)
                stdscr.clear()
                stdscr.refresh()
                continue

            if key == ord('q') or key == 27:  # q or Esc
                break

            elif key == curses.KEY_LEFT or key == ord('h'):
                shift = max(1, span // 4)
                start -= shift
                end -= shift

            elif key == curses.KEY_RIGHT or key == ord('l'):
                shift = max(1, span // 4)
                start += shift
                end += shift

            elif key == ord('H'):
                shift = max(1, span // 2)
                start -= shift
                end -= shift

            elif key == ord('L'):
                shift = max(1, span // 2)
                start += shift
                end += shift

            elif key == curses.KEY_UP or key == ord('k') or key == ord('+'):
                center = (start + end) // 2
                new_span = max(20, span // 2)
                start = center - new_span // 2
                end = start + new_span

            elif key == curses.KEY_DOWN or key == ord('j') or key == ord('-'):
                center = (start + end) // 2
                new_span = min(size, span * 2)
                start = center - new_span // 2
                end = start + new_span

            elif ord('1') <= key <= ord('8'):
                idx = key - ord('1')
                center = (start + end) // 2
                new_span = ZOOM_PRESETS[idx]
                start = center - new_span // 2
                end = start + new_span

            elif key == ord('r'):
                idx = RENDER_MODES.index(render_mode)
                render_mode = RENDER_MODES[(idx + 1) % len(RENDER_MODES)]
                labels = {'halfblock': 'half-block (2\u00d7 vert)',
                          'block': 'block (classic)',
                          'braille': 'braille (2\u00d7 horiz + 4\u00d7 vert)'}
                status_msg = f"Render: {labels[render_mode]}"

            elif key == ord('g'):
                result = self._browse_input(stdscr, "Goto: ")
                if result:
                    c, s, e = parse_region(result, chrom, self.chroms)
                    if c and c in self.chroms:
                        chrom = c
                        size = self.chroms[chrom]
                        start, end = s, e
                    else:
                        status_msg = f"Invalid: {result}"

            elif key == ord('c'):
                result = self._browse_input(stdscr, "Chrom: ")
                if result:
                    result = result.strip()
                    if result in self.chroms:
                        chrom = result
                        size = self.chroms[chrom]
                        start, end = 0, size
                    else:
                        matched = None
                        for cn in self.chroms:
                            if cn.lower() == result.lower():
                                matched = cn
                                break
                        if matched:
                            chrom = matched
                            size = self.chroms[chrom]
                            start, end = 0, size
                        else:
                            status_msg = f"Unknown: {result}"

            elif key == ord('s'):
                try:
                    vals = self._get_values(chrom, start, end)
                    nz = vals[vals > 0]
                    if len(nz) > 0:
                        status_msg = (f"min={np.min(vals):.3g}  max={np.max(vals):.3g}  "
                                      f"mean={np.mean(vals):.3g}  std={np.std(vals):.3g}  "
                                      f"median={np.median(vals):.3g}  "
                                      f"cov={len(nz)/len(vals)*100:.0f}%")
                    else:
                        status_msg = "No signal in region"
                except:
                    status_msg = "Stats error"

            elif key == ord('n'):
                self.nan_zero = not self.nan_zero
                status_msg = "nan=0 (mean)" if self.nan_zero else "skip NaN (nanmean)"

            elif key == ord('y'):
                result = self._browse_input(stdscr, "ylim (ymax or ymin ymax or auto): ")
                if result is not None:
                    r = result.strip()
                    if r.lower() == 'auto' or r == '':
                        self.ymin = [None] * self.n_tracks
                        self.ymax = [None] * self.n_tracks
                        status_msg = "ylim: auto"
                    else:
                        parts = r.split()
                        try:
                            if len(parts) == 1:
                                ylo, yhi = 0, float(parts[0])
                            else:
                                ylo, yhi = float(parts[0]), float(parts[1])
                            self.ymin = [ylo] * self.n_tracks
                            self.ymax = [yhi] * self.n_tracks
                            status_msg = f"ylim: [{ylo:.4g}, {yhi:.4g}]"
                        except ValueError:
                            status_msg = f"Invalid: {r}"

            elif key == curses.KEY_MOUSE:
                try:
                    _, mx, my, _, bstate = curses.getmouse()
                    if bstate & curses.BUTTON4_PRESSED:
                        center = (start + end) // 2
                        new_span = max(20, span * 2 // 3)
                        start = center - new_span // 2
                        end = start + new_span
                    elif bstate & (1 << 21):
                        center = (start + end) // 2
                        new_span = min(size, span * 3 // 2)
                        start = center - new_span // 2
                        end = start + new_span
                except:
                    pass

        self._set_region(chrom, start, end)

    def _browse_draw(self, stdscr, chrom, start, end, status_msg="",
                     render_mode='halfblock'):
        """Draw the browser view."""
        stdscr.erase()
        height, width = stdscr.getmaxyx()
        span = end - start
        size = self.chroms[chrom]

        plot_width = width - 12
        if plot_width < 10:
            stdscr.addstr(0, 0, "Terminal too narrow")
            stdscr.refresh()
            return

        # Braille uses 2x horizontal bins; block/halfblock use 1:1
        if render_mode == 'braille':
            data_bins = min(span, plot_width * 2)
        else:
            data_bins = min(span, plot_width)

        # Effective resolution
        if render_mode == 'braille':
            eff_w = plot_width * 2
            bp_per = span / max(1, eff_w)
            res_str = f"{bp_per:.0f} bp/dot" if bp_per >= 1 else f"{1/bp_per:.0f} dot/bp"
            mode_tag = " [braille]"
        elif render_mode == 'halfblock':
            bp_per = span / max(1, plot_width)
            res_str = f"{bp_per:.0f} bp/col" if bp_per >= 1 else f"{1/bp_per:.0f} col/bp"
            mode_tag = " [HD]"
        else:
            bp_per = span / max(1, plot_width)
            res_str = f"{bp_per:.0f} bp/col" if bp_per >= 1 else f"{1/bp_per:.0f} col/bp"
            mode_tag = " [block]"

        # ── Fetch per-track data ──
        track_data = []
        for ti, track in enumerate(self.tracks):
            try:
                vals = self._get_values_exact_track(track, chrom, start, end, nbins=data_bins)
            except Exception:
                vals = np.zeros(data_bins)
            dmax = np.max(vals) if len(vals) > 0 else 0
            dmin = np.min(vals) if len(vals) > 0 else 0
            dmean = np.mean(vals) if len(vals) > 0 else 0
            dcov = np.sum(vals > 0) / max(1, len(vals)) * 100
            dymin = self.ymin[ti] if self.ymin[ti] is not None else dmin
            dymax = self.ymax[ti] if self.ymax[ti] is not None else dmax
            if dymax <= dymin:
                dymax = dymin + 1
            track_data.append((vals, dmax, dmean, dcov, dymin, dymax))

        # ── Layout ──
        n = self.n_tracks
        overhead = 8  # header(2) + blank + xaxis + labels + minimap + help + margin
        separators = max(0, n - 1)
        available = max(n * 3, height - overhead - separators)
        track_h = available // n
        plot_start_row = 3

        # ── Header ──
        header = f" {chrom}:{format_pos(start)}-{format_pos(end)}  ({format_bp(span)})"
        self._safe_addstr(stdscr, 0, 0, header, curses.A_BOLD)

        nan_tag = "" if self.nan_zero else " [nanmean]"
        ylim_tag = "" if all(y is None for y in self.ymin) else " [ylim]"
        if n == 1:
            vals, dmax, dmean, dcov, _, _ = track_data[0]
            stats_line = (f" max={dmax:.2f}  mean={dmean:.2f}  "
                          f"cov={dcov:.0f}%  [{res_str}]{mode_tag}{nan_tag}{ylim_tag}")
        else:
            parts = []
            for ti, t in enumerate(self.tracks):
                _, dmax, dmean, dcov, _, _ = track_data[ti]
                parts.append(f"[{ti}]max={dmax:.2g}")
            stats_line = f" {'  '.join(parts)}  [{res_str}]{mode_tag}{nan_tag}{ylim_tag}"
        self._safe_addstr(stdscr, 1, 0, stats_line, curses.color_pair(3))

        # ── Signal plots (per-track) ──
        AXIS_ATTR = curses.color_pair(2)
        cur_row = plot_start_row

        for ti, track in enumerate(self.tracks):
            vals, dmax, dmean, dcov, dymin, dymax = track_data[ti]
            if n > 1:
                sig_attr = curses.color_pair(10 + ti % len(TRACK_CURSES_COLORS)) | curses.A_BOLD
            else:
                sig_attr = curses.color_pair(1) | curses.A_BOLD

            if dymax > dymin and len(vals) > 0:
                if render_mode == 'braille':
                    self._draw_braille(stdscr, vals, dymin, dymax, cur_row,
                                       track_h, plot_width, sig_attr, AXIS_ATTR)
                elif render_mode == 'halfblock':
                    self._draw_halfblock(stdscr, vals, dymin, dymax, cur_row,
                                         track_h, plot_width, sig_attr, AXIS_ATTR)
                else:
                    self._draw_blocks(stdscr, vals, dymin, dymax, cur_row,
                                      track_h, plot_width, sig_attr, AXIS_ATTR)
            else:
                row = cur_row + track_h // 2
                self._safe_addstr(stdscr, row, 10, "(no signal)", curses.A_DIM)
                for ri in range(track_h):
                    self._safe_addstr(stdscr, cur_row + ri, 0,
                                      f"{'':>8} \u2502", AXIS_ATTR)

            # Track label: overlay after ymax value on the top row
            if n > 1:
                label = ' ' + track.basename
                self._safe_addstr(stdscr, cur_row, 10,
                                  label, curses.color_pair(10 + ti % len(TRACK_CURSES_COLORS)))

            cur_row += track_h
            # Separator between tracks
            if ti < n - 1:
                sep = f"{'':>9}" + '\u2500' * min(plot_width, width - 10)
                self._safe_addstr(stdscr, cur_row, 0, sep, curses.A_DIM)
                cur_row += 1

        # ── X-axis ──
        xaxis_y = cur_row
        axis_line = f"{'':>9}\u2514" + '\u2500' * plot_width + '\u2518'
        self._safe_addstr(stdscr, xaxis_y, 0, axis_line, AXIS_ATTR)

        label_y = xaxis_y + 1
        left_label = format_pos(start)
        right_label = format_pos(end)
        mid_label = format_pos((start + end) // 2)
        self._safe_addstr(stdscr, label_y, 10, left_label, curses.A_DIM)
        mid_x = 10 + plot_width // 2 - len(mid_label) // 2
        if (mid_x > 10 + len(left_label) + 2
                and mid_x + len(mid_label) < 10 + plot_width - len(right_label) - 2):
            self._safe_addstr(stdscr, label_y, mid_x, mid_label, curses.A_DIM)
        self._safe_addstr(stdscr, label_y, 10 + plot_width - len(right_label),
                          right_label, curses.A_DIM)

        # ── Minimap ──
        minimap_y = height - 3
        if minimap_y > label_y + 1:
            mini_width = width - 4
            try:
                mini_vals = self.tracks[0].stats(chrom, 0, size, type="mean", nBins=mini_width)
                mini_arr = np.nan_to_num(np.array(mini_vals, dtype=np.float64), nan=0.0)
            except:
                mini_arr = np.zeros(mini_width)

            mini_max = np.max(mini_arr) if len(mini_arr) > 0 else 1
            if mini_max == 0:
                mini_max = 1

            vp_s = int(start / size * mini_width)
            vp_e = int(end / size * mini_width)
            vp_s = max(0, min(mini_width - 1, vp_s))
            vp_e = max(vp_s + 1, min(mini_width, vp_e))

            self._safe_addstr(stdscr, minimap_y, 0, f" {chrom} ", curses.A_DIM)
            offset = len(chrom) + 3

            for i in range(mini_width):
                x = offset + i
                if x >= width - 1:
                    break
                v = mini_arr[i] if i < len(mini_arr) else 0
                bi = min(8, max(0, int(v / mini_max * 8)))
                ch = BLOCKS[bi] if bi > 0 else '\u2581'

                if vp_s <= i < vp_e:
                    # Viewport: reverse video — always visible on any theme
                    self._safe_addstr(stdscr, minimap_y, x, ch, curses.A_REVERSE | curses.A_BOLD)
                else:
                    self._safe_addstr(stdscr, minimap_y, x, ch, curses.A_DIM)

        # ── Help bar ──
        help_y = height - 1
        if status_msg:
            self._safe_addstr(stdscr, help_y, 0, f" {status_msg}",
                              curses.color_pair(3) | curses.A_BOLD)
        else:
            help_str = (" \u2190\u2192:pan  \u2191\u2193:zoom  1-8:presets  "
                        "g:goto  c:chrom  r:render  n:nan  y:ylim  s:stats  q:quit")
            self._safe_addstr(stdscr, help_y, 0, help_str, curses.A_DIM)

        stdscr.refresh()

    def _draw_blocks(self, stdscr, vals, ymin, ymax, start_row, plot_h, plot_w,
                     sig_attr, axis_attr):
        """Block-character signal plot (1:1 column mapping), zero-baseline."""
        span_y = ymax - ymin
        # Resample to plot_w bins
        if len(vals) > plot_w:
            binned = np.array_split(vals, plot_w)
            pv = np.array([np.mean(b) for b in binned])
        elif len(vals) < plot_w:
            pv = np.interp(np.linspace(0, 1, plot_w),
                           np.linspace(0, 1, len(vals)), vals)
        else:
            pv = vals
        norm = np.clip((pv - ymin) / span_y * plot_h, 0, plot_h)
        zero_h = np.clip((0 - ymin) / span_y * plot_h, 0, plot_h)

        for ri in range(plot_h):
            row_val = plot_h - ri  # height from bottom for this row (top=plot_h)
            ry = start_row + ri

            if ri == 0:
                label = f"{ymax:>8.3g} \u2502"
            elif ri == plot_h - 1:
                label = f"{ymin:>8.3g} \u2502"
            elif ri == plot_h // 2:
                mid_val = (ymin + ymax) / 2
                label = f"{mid_val:>8.3g} \u2502"
            else:
                label = f"{'':>8} \u2502"
            self._safe_addstr(stdscr, ry, 0, label, axis_attr)

            chars = []
            for v in norm[:plot_w]:
                lo = min(v, zero_h)
                hi = max(v, zero_h)
                # Cell spans [row_val-1, row_val) in height-from-bottom
                overlap = max(0.0, min(hi, row_val) - max(lo, row_val - 1))
                if overlap >= 1.0:
                    chars.append('\u2588')
                elif overlap > 0:
                    idx = min(8, max(1, int(overlap * 8)))
                    chars.append(BLOCKS[idx])
                else:
                    chars.append(' ')
            self._safe_addstr(stdscr, ry, 10, ''.join(chars), sig_attr)

    def _draw_halfblock(self, stdscr, vals, ymin, ymax, start_row, plot_h, plot_w,
                        sig_attr, axis_attr):
        """Half-block signal plot with zero-baseline (2x vertical resolution).

        Uses \u2584 (lower half), \u2580 (upper half), and \u2588 (full block).
        """
        span_y = ymax - ymin
        px_h = plot_h * 2  # 2 vertical pixels per char row

        # Resample to plot_w (1:1 horizontal, same as block mode)
        if len(vals) > plot_w:
            binned = np.array_split(vals, plot_w)
            pv = np.array([np.mean(b) for b in binned])
        elif len(vals) < plot_w:
            pv = np.interp(np.linspace(0, 1, plot_w),
                           np.linspace(0, 1, len(vals)), vals)
        else:
            pv = vals
        norm = np.clip((pv - ymin) / span_y * px_h, 0, px_h)
        zero_h = np.clip((0 - ymin) / span_y * px_h, 0, px_h)

        for cr in range(plot_h):
            ry = start_row + cr

            # Y-axis label
            if cr == 0:
                label = f"{ymax:>8.3g} \u2502"
            elif cr == plot_h - 1:
                label = f"{ymin:>8.3g} \u2502"
            elif cr == plot_h // 2:
                mid_val = (ymin + ymax) / 2
                label = f"{mid_val:>8.3g} \u2502"
            else:
                label = f"{'':>8} \u2502"
            self._safe_addstr(stdscr, ry, 0, label, axis_attr)

            # Two pixel rows per character cell (bottom=lower, top=upper)
            py_lower = (plot_h - 1 - cr) * 2      # pixel y of lower half
            py_upper = (plot_h - 1 - cr) * 2 + 1  # pixel y of upper half

            chars = []
            for v in norm[:plot_w]:
                lo = min(v, zero_h)
                hi = max(v, zero_h)
                # Does the bar cover each half-pixel?
                upper_on = (hi > py_upper and lo < py_upper + 1)
                lower_on = (hi > py_lower and lo < py_lower + 1)
                if upper_on and lower_on:
                    chars.append('\u2588')   # full block
                elif lower_on:
                    chars.append('\u2584')   # lower half
                elif upper_on:
                    chars.append('\u2580')   # upper half
                else:
                    chars.append(' ')
            self._safe_addstr(stdscr, ry, 10, ''.join(chars), sig_attr)

    def _draw_braille(self, stdscr, vals, ymin, ymax, start_row, plot_h, plot_w,
                      sig_attr, axis_attr):
        """Braille signal plot: 2x horizontal, 4x vertical resolution.

        Each character cell is a 2-wide x 4-tall dot matrix (U+2800-U+28FF).
        Effective pixel grid: (plot_w * 2) x (plot_h * 4).
        """
        span_y = ymax - ymin
        px_w = plot_w * 2
        px_h = plot_h * 4

        # Resample to pixel width
        if len(vals) > px_w:
            binned = np.array_split(vals, px_w)
            pv = np.array([np.mean(b) for b in binned])
        elif len(vals) < px_w:
            pv = np.interp(np.linspace(0, 1, px_w),
                           np.linspace(0, 1, len(vals)), vals)
        else:
            pv = vals
        norm = np.clip((pv - ymin) / span_y * px_h, 0, px_h)
        zero_h = np.clip((0 - ymin) / span_y * px_h, 0, px_h)

        # Braille dot bits: [sub_row][sub_col] -> bitmask
        # sub_row 0 = top of cell, 3 = bottom
        DB = [[0x01, 0x08],   # row 0
              [0x02, 0x10],   # row 1
              [0x04, 0x20],   # row 2
              [0x40, 0x80]]   # row 3

        for cr in range(plot_h):
            ry = start_row + cr

            # Y-axis label
            if cr == 0:
                label = f"{ymax:>8.3g} \u2502"
            elif cr == plot_h - 1:
                label = f"{ymin:>8.3g} \u2502"
            elif cr == plot_h // 2:
                mid_val = (ymin + ymax) / 2
                label = f"{mid_val:>8.3g} \u2502"
            else:
                label = f"{'':>8} \u2502"
            self._safe_addstr(stdscr, ry, 0, label, axis_attr)

            chars = []
            for cc in range(plot_w):
                code = 0x2800  # braille blank
                for sc in range(2):  # left/right dot column
                    px_x = cc * 2 + sc
                    if px_x >= len(norm):
                        continue
                    h = norm[px_x]
                    lo = min(h, zero_h)
                    hi = max(h, zero_h)
                    for sr in range(4):  # dot rows top-to-bottom
                        # pixel y for this dot (0 = bottom of plot)
                        py = (plot_h - 1 - cr) * 4 + (3 - sr)
                        if py >= lo and py < hi:
                            code |= DB[sr][sc]
                chars.append(chr(code))
            self._safe_addstr(stdscr, ry, 10, ''.join(chars), sig_attr)

    def _browse_input(self, stdscr, prompt):
        """Get text input in curses mode."""
        height, width = stdscr.getmaxyx()
        y = height - 1
        curses.echo()
        curses.curs_set(1)
        stdscr.move(y, 0)
        stdscr.clrtoeol()
        self._safe_addstr(stdscr, y, 0, prompt, curses.A_BOLD)
        stdscr.refresh()
        try:
            raw = stdscr.getstr(y, len(prompt), min(60, width - len(prompt) - 1))
            result = raw.decode('utf-8').strip()
        except:
            result = ""
        curses.noecho()
        curses.curs_set(0)
        return result

    @staticmethod
    def _safe_addstr(win, y, x, s, attr=0):
        """addstr that silently clips to window bounds."""
        try:
            height, width = win.getmaxyx()
            if y < 0 or y >= height or x >= width:
                return
            max_len = width - x - 1
            if max_len <= 0:
                return
            win.addnstr(y, x, s, max_len, attr)
        except curses.error:
            pass

    # ── Sixel pixel browser ───────────────────────────────────

    def do_bp(self, arg):
        """Pixel-mode browser (sixel graphics).  Usage: bp [region]

        Same keybindings as browse. Renders signal as actual pixels
        via sixel protocol — true pixel resolution, no character grid.
        Requires a sixel-capable terminal (iTerm2, WezTerm, foot, kitty*, xterm).

        Keys: same as browse (arrows/hjkl pan/zoom, 1-8 presets, g goto,
              c chrom, s stats, q quit)
        """
        chrom, start, end = self._parse(arg)
        if chrom is None:
            if self.chrom:
                chrom = self.chrom
                start, end = 0, self.chroms[chrom]
            else:
                chrom = sorted(self.chroms.keys())[0]
                start, end = 0, self.chroms[chrom]

        size = self.chroms.get(chrom, 0)
        start = max(0, start)
        end = min(size, end)

        try:
            self._browse_sixel(chrom, start, end)
        except Exception as e:
            print(f"Sixel browser error: {e}")

    complete_bp = _complete_chrom

    def _get_terminal_pixels(self):
        """Query terminal pixel dimensions. Returns (rows, cols, xpix, ypix)."""
        try:
            fd = sys.stdin.fileno()
            result = fcntl.ioctl(fd, termios.TIOCGWINSZ, b'\x00' * 8)
            rows, cols, xpix, ypix = struct.unpack('HHHH', result)
            if xpix > 0 and ypix > 0:
                return rows, cols, xpix, ypix
        except:
            pass
        # Fallback: estimate from character size
        rows, cols = shutil.get_terminal_size()
        return rows, cols, cols * 8, rows * 16

    _resized = False

    def _read_key(self, fd):
        """Read a single keypress in raw/cbreak terminal mode."""
        # Poll with timeout so SIGWINCH (which sets _resized) is detected
        # promptly — Python 3.5+ auto-retries os.read on EINTR (PEP 475),
        # so we can't rely on OSError to wake us up.
        while True:
            if self._resized:
                self._resized = False
                return 'RESIZE'
            ready, _, _ = select.select([fd], [], [], 0.1)
            if not ready:
                continue
            try:
                ch = os.read(fd, 1)
            except OSError:
                self._resized = False
                return 'RESIZE'
            if not ch:
                return ''
            if self._resized:
                self._resized = False
                return 'RESIZE'
            break
        if ch == b'\x1b':
            # Possible escape sequence
            if select.select([fd], [], [], 0.05)[0]:
                ch2 = os.read(fd, 1)
                if ch2 == b'[':
                    if select.select([fd], [], [], 0.05)[0]:
                        ch3 = os.read(fd, 1)
                        if ch3 == b'A': return 'UP'
                        if ch3 == b'B': return 'DOWN'
                        if ch3 == b'C': return 'RIGHT'
                        if ch3 == b'D': return 'LEFT'
                        # Consume any remaining bytes
                        while select.select([fd], [], [], 0.01)[0]:
                            os.read(fd, 1)
            return 'ESC'
        if ch == b'\r' or ch == b'\n':
            return 'ENTER'
        try:
            return ch.decode('ascii')
        except:
            return ''

    def _read_line_esc(self, fd):
        """Read a line in cbreak mode; ESC cancels (returns None), Enter confirms."""
        buf = []
        w = sys.stdout.write
        while True:
            ch = os.read(fd, 1)
            if ch == b'\x1b':  # ESC
                # Drain any escape sequence bytes
                while select.select([fd], [], [], 0.03)[0]:
                    os.read(fd, 1)
                return None
            elif ch == b'\r' or ch == b'\n':
                w('\r\n')
                sys.stdout.flush()
                return ''.join(buf)
            elif ch in (b'\x7f', b'\x08'):  # Backspace/DEL
                if buf:
                    buf.pop()
                    w('\b \b')
                    sys.stdout.flush()
            elif ch == b'\x03':  # Ctrl-C
                return None
            else:
                try:
                    c = ch.decode('ascii')
                    if c.isprintable():
                        buf.append(c)
                        w(c)
                        sys.stdout.flush()
                except Exception:
                    pass
        return ''.join(buf)

    def _render_signal_pixels(self, vals, width, height, ymin=0, ymax=None,
                              signal_pv=1, axis_pv=2):
        """Render signal to pixel array with zero-baseline.

        Pixel values: 0=bg, signal_pv=signal fill, axis_pv=axis lines.
        Positive values fill upward from zero; negative values fill downward.
        """
        if len(vals) != width:
            resampled = np.interp(
                np.linspace(0, 1, width),
                np.linspace(0, 1, len(vals)), vals)
        else:
            resampled = np.asarray(vals, dtype=np.float64)

        if ymax is None:
            ymax = np.max(resampled)
        span_y = ymax - ymin
        if span_y <= 0:
            pixels = np.zeros((height, width), dtype=np.uint8)
        else:
            # Norm: height from bottom in pixels for each value and for zero
            norm = np.clip((resampled - ymin) / span_y * height, 0, height)
            zero_h = np.clip((0 - ymin) / span_y * height, 0, height)

            # Convert to row indices (row 0 = top)
            val_row = (height - norm).astype(np.float64)   # per-column
            zero_row = float(height - zero_h)

            # Fill between zero_row and val_row for each column
            top = np.minimum(val_row, zero_row)[np.newaxis, :]
            bot = np.maximum(val_row, zero_row)[np.newaxis, :]
            row_idx = np.arange(height, dtype=np.float64)[:, np.newaxis]
            pixels = np.where((row_idx >= top) & (row_idx < bot),
                              signal_pv, np.uint8(0)).astype(np.uint8)

        # Axis lines (drawn on top of signal)
        pixels[-1, :] = axis_pv     # x-axis along bottom
        pixels[:, 0] = axis_pv      # y-axis along left edge
        # Zero line (if zero is visible in range)
        if span_y > 0 and ymin < 0 < ymax:
            zero_px_row = int(height - (0 - ymin) / span_y * height)
            if 0 <= zero_px_row < height:
                pixels[zero_px_row, :] = axis_pv
        # Y-axis tick marks at 25%, 50%, 75%
        for frac in (0.25, 0.5, 0.75):
            y = int(height * (1 - frac))
            if 0 <= y < height:
                pixels[y, 0:4] = axis_pv

        return pixels

    def _encode_sixel(self, pixels, n_signals=1):
        """Encode pixel array as sixel with dynamic number of colors.

        pixels: (H, W) uint8 — 0=background, 1..n_signals=track signals,
                n_signals+1=axis.
        n_signals: number of signal tracks (determines color palette).
        """
        h, w = pixels.shape
        pad = (6 - h % 6) % 6
        if pad:
            pixels = np.vstack([np.zeros((pad, w), dtype=np.uint8), pixels])
            h += pad

        axis_pv = n_signals + 1
        n_vals = axis_pv + 1  # total distinct pixel values

        n_bands = h // 6
        parts = ['\033Pq']
        parts.append(f'"1;1;{w};{h}')

        # Color definitions
        if n_signals == 1:
            # Single track: monochrome grey (backward compat)
            if self.dark_bg:
                parts.append('#0;2;12;12;12')     # bg
                parts.append('#1;2;85;85;85')     # signal
                parts.append('#2;2;35;35;35')     # axis
            else:
                parts.append('#0;2;100;100;100')  # bg
                parts.append('#1;2;8;8;8')        # signal
                parts.append('#2;2;65;65;65')     # axis
        else:
            # Multi-track: colored per track
            if self.dark_bg:
                parts.append('#0;2;12;12;12')     # bg
            else:
                parts.append('#0;2;100;100;100')  # bg
            for ti in range(n_signals):
                dark_rgb, light_rgb = TRACK_SIXEL[ti % len(TRACK_SIXEL)]
                r, g, b = dark_rgb if self.dark_bg else light_rgb
                parts.append(f'#{ti + 1};2;{r};{g};{b}')
            # Axis color
            if self.dark_bg:
                parts.append(f'#{axis_pv};2;35;35;35')
            else:
                parts.append(f'#{axis_pv};2;65;65;65')

        for band in range(n_bands):
            chunk = pixels[band * 6:band * 6 + 6, :]
            first = True

            for val in range(n_vals):
                mask = (chunk == val)
                packed = np.zeros(w, dtype=np.uint8)
                for bit in range(6):
                    packed |= (mask[bit].astype(np.uint8) << bit)
                if not np.any(packed):
                    continue
                if not first:
                    parts.append('$')  # rewind to start of band
                parts.append('#%d' % val)
                parts.append(self._sixel_rle(packed))
                first = False

            if band + 1 < n_bands:
                parts.append('-')

        parts.append('\033\\')
        return ''.join(parts)

    @staticmethod
    def _sixel_rle(packed):
        """RLE-encode a row of sixel values (numpy uint8 array)."""
        # Convert to sixel characters
        chars = (packed + 0x3F).tobytes()
        if not chars:
            return ''

        result = []
        i = 0
        n = len(chars)
        while i < n:
            ch = chars[i]
            count = 1
            while i + count < n and chars[i + count] == ch and count < 255:
                count += 1
            if count >= 3:
                result.append(f'!{count}')
                result.append(chr(ch))
            else:
                result.append(chr(ch) * count)
            i += count
        return ''.join(result)

    def _browse_sixel(self, chrom, start, end):
        """Sixel-based interactive genome browser."""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)

        ZOOM_PRESETS = [100, 1_000, 10_000, 100_000, 1_000_000,
                        10_000_000, 50_000_000, 100_000_000]
        status_msg = ''
        w = sys.stdout.write

        old_sigwinch = signal.getsignal(signal.SIGWINCH)

        def _on_resize(signum, frame):
            self._resized = True

        try:
            signal.signal(signal.SIGWINCH, _on_resize)
            tty.setcbreak(fd)
            w('\033[?25l')  # hide cursor
            sys.stdout.flush()

            while True:
                size = self.chroms[chrom]
                start = max(0, min(start, size - 100))
                end = max(start + 20, min(end, size))
                span = end - start

                # Terminal dimensions
                t_rows, t_cols, t_xpix, t_ypix = self._get_terminal_pixels()
                cell_w = max(1, t_xpix // t_cols)
                cell_h = max(1, t_ypix // t_rows)

                # Text lines: header(1) + stats(1) + [plot] + xaxis(1) + help(1) = 4
                text_lines = 4
                y_margin = 8  # chars reserved for y-axis labels
                plot_char_rows = max(5, t_rows - text_lines)
                plot_px_w = max(100, (t_cols - y_margin) * cell_w)
                total_px_h = max(50, plot_char_rows * cell_h)

                nt = self.n_tracks
                axis_pv = nt + 1
                sep_px = 2 if nt > 1 else 0  # pixel separator between tracks
                usable_px = total_px_h - sep_px * max(0, nt - 1)
                track_px_h = max(20, usable_px // nt)

                # Fetch data for all tracks
                nbins = min(span, plot_px_w)
                track_vals = []
                track_ymins = []
                track_ymaxs = []
                for ti, tr in enumerate(self.tracks):
                    try:
                        v = self._get_values_exact_track(tr, chrom, start, end, nbins=nbins)
                    except:
                        v = np.zeros(nbins)
                    track_vals.append(v)
                    dmin = np.min(v) if len(v) > 0 else 0
                    dmax = np.max(v) if len(v) > 0 else 0
                    ylo = self.ymin[ti] if self.ymin[ti] is not None else dmin
                    yhi = self.ymax[ti] if self.ymax[ti] is not None else dmax
                    if yhi <= ylo:
                        yhi = ylo + 1
                    track_ymins.append(ylo)
                    track_ymaxs.append(yhi)

                # Render and stack pixel arrays
                pixel_strips = []
                for ti in range(nt):
                    pv = ti + 1
                    px = self._render_signal_pixels(
                        track_vals[ti], plot_px_w, track_px_h,
                        ymin=track_ymins[ti], ymax=track_ymaxs[ti],
                        signal_pv=pv, axis_pv=axis_pv)
                    pixel_strips.append(px)
                    if ti < nt - 1 and sep_px > 0:
                        sep = np.full((sep_px, plot_px_w), axis_pv, dtype=np.uint8)
                        pixel_strips.append(sep)

                pixels = np.vstack(pixel_strips)
                actual_px_h = pixels.shape[0]
                sixel = self._encode_sixel(pixels, n_signals=nt)

                bp_px = span / max(1, plot_px_w)

                # Draw screen (synchronized output prevents flashing)
                w('\033[?2026h')
                w('\033[2J\033[H')

                BO = '\033[1m'
                DM = '\033[2m'
                RS = '\033[0m'

                # Header (rows 1-2)
                header = f" {chrom}:{format_pos(start)}-{format_pos(end)}  ({format_bp(span)})"
                res_str = f"{bp_px:.1f} bp/px" if bp_px >= 1 else f"{1/bp_px:.0f} px/bp"
                nan_tag = "" if self.nan_zero else " [nanmean]"
                ylim_tag = "" if all(y is None for y in self.ymin) else " [ylim]"
                if nt == 1:
                    v0 = track_vals[0]
                    data_max = np.max(v0) if len(v0) > 0 else 0
                    vmean = np.mean(v0) if len(v0) > 0 else 0
                    nz_frac = np.sum(v0 > 0) / max(1, len(v0)) * 100
                    stats_line = (f" max={data_max:.2f}  mean={vmean:.2f}  "
                                  f"cov={nz_frac:.0f}%  [{res_str}]  "
                                  f"[{plot_px_w}\u00d7{actual_px_h}px]{nan_tag}{ylim_tag}")
                else:
                    maxes = '  '.join(
                        f"{tr.basename}:{np.max(v):.3g}"
                        for tr, v in zip(self.tracks, track_vals)
                        if len(v) > 0)
                    stats_line = (f" max: {maxes}  [{res_str}]  "
                                  f"[{plot_px_w}\u00d7{actual_px_h}px]{nan_tag}{ylim_tag}")
                w(f'{BO}{header}{RS}\r\n')
                w(f'{DM}{stats_line}{RS}\r\n')

                # Sixel image indented to leave room for y-axis labels
                img_top = 3  # row where image starts (1-indexed)
                w(f'\033[{y_margin}C')  # indent
                w(sixel)

                # Y-axis labels overlaid at left margin (per track)
                sixel_char_rows = (actual_px_h + cell_h - 1) // cell_h
                track_char_h = (track_px_h + cell_h - 1) // cell_h
                sep_char_h = (sep_px + cell_h - 1) // cell_h if sep_px > 0 else 0
                for ti in range(nt):
                    row_off = img_top + ti * (track_char_h + sep_char_h)
                    yhi = track_ymaxs[ti]
                    ylo = track_ymins[ti]
                    mid_val = (ylo + yhi) / 2
                    # Top row: ymax + track name (for multi-track)
                    if nt > 1:
                        tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                        w(f'\033[{row_off};1H{DM}{yhi:>7.3g}{RS}'
                          f' {tc}{self.tracks[ti].basename}{RS}')
                    else:
                        w(f'\033[{row_off};1H{DM}{yhi:>7.3g}{RS}')
                    # Zero line label (if zero is visible)
                    if ylo < 0 < yhi:
                        zero_frac = (0 - ylo) / (yhi - ylo)
                        zero_r = row_off + int(track_char_h * (1 - zero_frac))
                        if zero_r != row_off and zero_r != row_off + track_char_h - 1:
                            w(f'\033[{zero_r};1H{DM}{"0":>7s}{RS}')
                    mid_r = row_off + track_char_h // 2
                    w(f'\033[{mid_r};1H{DM}{mid_val:>7.3g}{RS}')
                    bot_r = row_off + track_char_h - 1
                    w(f'\033[{bot_r};1H{DM}{ylo:>7.3g}{RS}')

                # Move below sixel for x-axis labels
                after_row = img_top + sixel_char_rows
                w(f'\033[{after_row};1H')

                # X-axis labels (indented to match plot)
                left_l = format_pos(start)
                right_l = format_pos(end)
                mid_l = format_pos((start + end) // 2)
                avail = t_cols - y_margin - len(left_l) - len(right_l)
                label_pad = ' ' * y_margin
                w(f'{DM}{label_pad}{left_l}')
                if avail > len(mid_l) + 4:
                    half = avail // 2
                    w(' ' * (half - len(mid_l) // 2) + mid_l)
                    w(' ' * (avail - half - len(mid_l) + len(mid_l) // 2) + right_l)
                else:
                    w(' ' * max(1, avail) + right_l)
                w(f'{RS}\r\n')

                # Help / status
                if status_msg:
                    w(f' {BO}{status_msg}{RS}')
                else:
                    w(f' {DM}\u2190/\u2192:pan  \u2191/\u2193:zoom  '
                      f'1-8:presets  g:goto  c:chrom  n:nan  y:ylim  t:theme  s:stats  q:quit{RS}')
                w('\033[?2026l')
                sys.stdout.flush()
                status_msg = ''

                # Read keypress
                key = self._read_key(fd)

                if key == 'RESIZE':
                    continue  # redraw at new size
                if key == 'q' or key == 'ESC':
                    break
                elif key == 'LEFT' or key == 'h':
                    shift = max(1, span // 4)
                    start -= shift; end -= shift
                elif key == 'RIGHT' or key == 'l':
                    shift = max(1, span // 4)
                    start += shift; end += shift
                elif key == 'H':
                    shift = max(1, span // 2)
                    start -= shift; end -= shift
                elif key == 'L':
                    shift = max(1, span // 2)
                    start += shift; end += shift
                elif key == 'UP' or key == 'k' or key == '+':
                    center = (start + end) // 2
                    new_span = max(20, span // 2)
                    start = center - new_span // 2
                    end = start + new_span
                elif key == 'DOWN' or key == 'j' or key == '-':
                    center = (start + end) // 2
                    new_span = min(size, span * 2)
                    start = center - new_span // 2
                    end = start + new_span
                elif key in '12345678':
                    idx = int(key) - 1
                    center = (start + end) // 2
                    new_span = ZOOM_PRESETS[idx]
                    start = center - new_span // 2
                    end = start + new_span
                elif key == 's':
                    try:
                        parts_s = []
                        for ti, tr in enumerate(self.tracks):
                            sv = self._get_values_track(tr, chrom, start, end)
                            nz = sv[sv > 0]
                            if len(nz) > 0:
                                label = tr.basename + ': ' if nt > 1 else ''
                                parts_s.append(
                                    f"{label}min={np.min(sv):.3g} max={np.max(sv):.3g} "
                                    f"mean={np.mean(sv):.3g} cov={len(nz)/len(sv)*100:.0f}%")
                            else:
                                parts_s.append(f"{tr.basename}: no signal" if nt > 1 else "No signal")
                        status_msg = '  |  '.join(parts_s)
                    except:
                        status_msg = "Stats error"
                elif key == 'n':
                    self.nan_zero = not self.nan_zero
                    status_msg = "nan=0 (mean)" if self.nan_zero else "skip NaN (nanmean)"
                elif key == 't':
                    self.dark_bg = not self.dark_bg
                    status_msg = "dark theme" if self.dark_bg else "light theme"
                elif key == 'y':
                    w('\r\n ylim (ymax or ymin ymax or auto): ')
                    w('\033[?25h')
                    sys.stdout.flush()
                    result = self._read_line_esc(fd)
                    w('\033[?25l')
                    sys.stdout.flush()
                    if result is not None:
                        r = result.strip()
                        if r.lower() == 'auto' or r == '':
                            self.ymin = [None] * self.n_tracks
                            self.ymax = [None] * self.n_tracks
                            status_msg = "ylim: auto"
                        else:
                            parts = r.split()
                            try:
                                if len(parts) == 1:
                                    ylo, yhi = 0, float(parts[0])
                                else:
                                    ylo, yhi = float(parts[0]), float(parts[1])
                                self.ymin = [ylo] * self.n_tracks
                                self.ymax = [yhi] * self.n_tracks
                                status_msg = f"ylim: [{ylo:.4g}, {yhi:.4g}]"
                            except ValueError:
                                status_msg = f"Invalid: {r}"
                elif key == 'g':
                    w('\r\n Goto: ')
                    w('\033[?25h')
                    sys.stdout.flush()
                    result = self._read_line_esc(fd)
                    w('\033[?25l')
                    sys.stdout.flush()
                    if result:
                        c, s, e = parse_region(result, chrom, self.chroms)
                        if c and c in self.chroms:
                            chrom, start, end = c, s, e
                        else:
                            status_msg = f"Invalid: {result}"
                elif key == 'c':
                    w('\r\n Chrom: ')
                    w('\033[?25h')
                    sys.stdout.flush()
                    result = self._read_line_esc(fd)
                    w('\033[?25l')
                    sys.stdout.flush()
                    if result:
                        matched = result.strip()
                        if matched not in self.chroms:
                            for cn in self.chroms:
                                if cn.lower() == matched.lower():
                                    matched = cn
                                    break
                        if matched in self.chroms:
                            chrom = matched
                            start, end = 0, self.chroms[matched]
                        else:
                            status_msg = f"Unknown: {result}"

        finally:
            signal.signal(signal.SIGWINCH, old_sigwinch)
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            w('\033[?25h')   # show cursor
            w('\033[2J\033[H')  # clear
            sys.stdout.flush()

        self._set_region(chrom, start, end)

    # ── Metadata ─────────────────────────────────────────────

    def do_info(self, arg):
        """File and chromosome info.  Usage: info [chrom]"""
        if arg.strip() and arg.strip() in self.chroms:
            chrom = arg.strip()
            size = self.chroms[chrom]
            print(f"  {C.BOLD}Chromosome:{C.RESET} {chrom}")
            print(f"  {C.BOLD}Size:{C.RESET}       {format_bp(size)} ({size:,} bp)")

            for ti, tr in enumerate(self.tracks):
                if chrom not in tr.chroms:
                    if self.n_tracks > 1:
                        tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                        print(f"  {tc}{tr.basename}{C.RESET}: (no {chrom})")
                    continue
                st = tr.bw.stats(chrom, 0, size, type="mean", nBins=1)
                st_max = tr.bw.stats(chrom, 0, size, type="max", nBins=1)
                st_min = tr.bw.stats(chrom, 0, size, type="min", nBins=1)
                cov = tr.bw.stats(chrom, 0, size, type="coverage", nBins=1)
                mean_val = st[0] if st[0] is not None else 0
                max_val = st_max[0] if st_max[0] is not None else 0
                min_val = st_min[0] if st_min[0] is not None else 0
                cov_val = cov[0] if cov[0] is not None else 0
                if self.n_tracks > 1:
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    print(f"  {tc}{C.BOLD}{tr.basename}{C.RESET}")
                print(f"  {C.BOLD}Min:{C.RESET}        {min_val:.4f}")
                print(f"  {C.BOLD}Max:{C.RESET}        {max_val:.4f}")
                print(f"  {C.BOLD}Mean:{C.RESET}       {mean_val:.4f}")
                print(f"  {C.BOLD}Coverage:{C.RESET}   {cov_val * 100:.1f}%")
            return

        # File-level info (per track)
        total_bp = sum(self.chroms.values())
        n_main = sum(1 for c in self.chroms if '_' not in c or c.startswith('chr'))

        for ti, tr in enumerate(self.tracks):
            fsize = format_size(os.path.getsize(tr.filename))
            if self.n_tracks > 1:
                tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                print(f"\n  {tc}{C.BOLD}{tr.basename}{C.RESET}")
            print(f"  {C.BOLD}File:{C.RESET}        {tr.filename}")
            print(f"  {C.BOLD}Size:{C.RESET}        {fsize}")
            print(f"  {C.BOLD}Chromosomes:{C.RESET} {len(tr.chroms)}")

            header = tr.bw.header()
            if header:
                if 'nBasesCovered' in header:
                    covered = header['nBasesCovered']
                    t_bp = sum(tr.chroms.values())
                    pct = 100 * covered / t_bp if t_bp > 0 else 0
                    print(f"  {C.BOLD}Bases covered:{C.RESET} {covered:,} ({pct:.1f}%)")
                if 'minVal' in header:
                    print(f"  {C.BOLD}Value range:{C.RESET}  [{header['minVal']:.4f}, {header['maxVal']:.4f}]")
                if 'sumData' in header and 'nBasesCovered' in header and header['nBasesCovered'] > 0:
                    mean = header['sumData'] / header['nBasesCovered']
                    print(f"  {C.BOLD}Mean (covered):{C.RESET} {mean:.4f}")

        if self.n_tracks > 1:
            print(f"\n  {C.BOLD}Union chroms:{C.RESET} {len(self.chroms)} ({n_main} main)")
            print(f"  {C.BOLD}Total span:{C.RESET}  {format_bp(total_bp)}")

    complete_info = _complete_chrom

    def do_ylim(self, arg):
        """Set y-axis limits.  Usage: ylim [ymin ymax | ymax | auto]

        Examples:
            ylim 0 5        Fix y-axis to 0-5
            ylim 5          Fix ymax to 5, ymin to 0
            ylim -2 5       Fix y-axis to -2 to 5
            ylim auto       Reset to auto-scaling (default)
            ylim            Show current setting
        """
        arg = arg.strip()
        if not arg:
            for ti, t in enumerate(self.tracks):
                ymin_s = "auto" if self.ymin[ti] is None else f"{self.ymin[ti]:.4g}"
                ymax_s = "auto" if self.ymax[ti] is None else f"{self.ymax[ti]:.4g}"
                prefix = f"  [{t.basename}] " if self.n_tracks > 1 else "  "
                print(f"{prefix}ylim: [{ymin_s}, {ymax_s}]")
            return
        if arg.lower() == 'auto':
            self.ymin = [None] * self.n_tracks
            self.ymax = [None] * self.n_tracks
            print(f"  ylim: {C.BOLD}auto{C.RESET}")
            return
        parts = arg.split()
        try:
            if len(parts) == 1:
                ylo, yhi = 0, float(parts[0])
            else:
                ylo, yhi = float(parts[0]), float(parts[1])
            self.ymin = [ylo] * self.n_tracks
            self.ymax = [yhi] * self.n_tracks
            print(f"  ylim: {C.BOLD}[{ylo:.4g}, {yhi:.4g}]{C.RESET}")
        except ValueError:
            print(f"  Invalid: {arg}. Use 'ylim ymin ymax' or 'ylim auto'")

    def do_nanmode(self, arg):
        """Toggle NaN handling.  Usage: nanmode [on|off]

        on  = treat missing/NaN as zero (mean, default)
        off = ignore missing positions  (nanmean)
        """
        arg = arg.strip().lower()
        if arg == 'on':
            self.nan_zero = True
        elif arg == 'off':
            self.nan_zero = False
        else:
            self.nan_zero = not self.nan_zero
        mode = "nan=0 (mean)" if self.nan_zero else "skip NaN (nanmean)"
        print(f"  NaN mode: {C.BOLD}{mode}{C.RESET}")

    def do_stats(self, arg):
        """Region statistics.  Usage: stats <region>

        Examples:
            stats chr1:1000-2000
            stats chr1              (whole chromosome)
        """
        chrom, start, end = self._parse(arg)
        if chrom is None:
            print(f"{C.RED}Cannot parse region. Usage: stats chr1:1000-2000{C.RESET}")
            return
        if chrom not in self.chroms:
            print(f"{C.RED}Unknown chromosome: {chrom}{C.RESET}")
            return

        size = self.chroms[chrom]
        start = max(0, start)
        end = min(size, end)
        span = end - start

        self._set_region(chrom, start, end)

        print(f"  {C.BOLD}Region:{C.RESET}    {chrom}:{format_pos(start)}-{format_pos(end)}"
              f" ({format_bp(span)})")

        for ti, tr in enumerate(self.tracks):
            if self.n_tracks > 1:
                tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                print(f"\n  {tc}{C.BOLD}{tr.basename}{C.RESET}")

            # Use binned stats for large regions, per-base for small
            if span <= 1_000_000:
                vals = np.nan_to_num(
                    np.array(tr.values(chrom, start, end), dtype=np.float64), nan=0.0)
            else:
                nbins = min(span, 100_000)
                vals = self._get_values_exact_track(tr, chrom, start, end, nbins=nbins)

            nonzero = vals[vals > 0]
            coverage = len(nonzero) / len(vals) * 100 if len(vals) > 0 else 0

            print(f"  {C.BOLD}Min:{C.RESET}       {np.min(vals):.6g}")
            print(f"  {C.BOLD}Max:{C.RESET}       {np.max(vals):.6g}")
            print(f"  {C.BOLD}Mean:{C.RESET}      {np.mean(vals):.6g}")
            print(f"  {C.BOLD}Std:{C.RESET}       {np.std(vals):.6g}")
            if len(nonzero) > 0:
                print(f"  {C.BOLD}Mean (nz):{C.RESET} {np.mean(nonzero):.6g}")
            print(f"  {C.BOLD}Median:{C.RESET}    {np.median(vals):.6g}")
            pcts = np.percentile(vals, [1, 25, 75, 99])
            print(f"  {C.BOLD}P1/P25/P75/P99:{C.RESET} {pcts[0]:.4g} / {pcts[1]:.4g} / "
                  f"{pcts[2]:.4g} / {pcts[3]:.4g}")
            print(f"  {C.BOLD}Coverage:{C.RESET}  {coverage:.1f}%")
            print(f"  {C.BOLD}Sum:{C.RESET}       {np.sum(vals):.6g}")

    complete_stats = _complete_chrom

    # ── Analysis ─────────────────────────────────────────────

    def do_hist(self, arg):
        """Text histogram of signal values.  Usage: hist [-b BINS] <region>"""
        parts = arg.split()
        bins = 20
        i = 0
        remaining = []
        while i < len(parts):
            if parts[i] == '-b' and i + 1 < len(parts):
                bins = int(parts[i + 1])
                i += 2
            else:
                remaining.append(parts[i])
                i += 1

        region_arg = ' '.join(remaining)
        chrom, start, end = self._parse(region_arg)
        if chrom is None:
            print(f"{C.RED}Cannot parse region. Usage: hist chr1:1000-2000{C.RESET}")
            return

        size = self.chroms.get(chrom, 0)
        start = max(0, start)
        end = min(size, end)
        span = end - start

        tw = shutil.get_terminal_size((80, 24)).columns
        bar_width = max(10, min(40, tw - 35))

        for ti, tr in enumerate(self.tracks):
            vals = self._get_values_track(tr, chrom, start, end)
            nonzero = vals[vals > 0]
            if len(nonzero) == 0:
                if self.n_tracks > 1:
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    print(f"  {tc}{tr.basename}{C.RESET}: (all zeros)")
                else:
                    print("  (all zeros)")
                continue

            zero_frac = (len(vals) - len(nonzero)) / len(vals) * 100
            bc = TRACK_ANSI[ti % len(TRACK_ANSI)] if self.n_tracks > 1 else C.GREEN

            if self.n_tracks > 1:
                print(f"\n  {bc}{C.BOLD}{tr.basename}{C.RESET}")
            print(f"  {C.DIM}(zeros: {zero_frac:.1f}% of {len(vals):,} bins, "
                  f"histogram of non-zero values){C.RESET}")

            counts, edges = np.histogram(nonzero, bins=bins)
            max_count = max(counts)

            for i in range(len(counts)):
                lo, hi = edges[i], edges[i + 1]
                bar_len = int(counts[i] / max_count * bar_width) if max_count > 0 else 0
                bar = '\u2588' * bar_len
                pct = 100 * counts[i] / len(nonzero)
                print(f"  [{lo:>9.3g},{hi:>9.3g})"
                      f" {bc}{bar}{C.RESET} {counts[i]:>7,} ({pct:4.1f}%)")

    complete_hist = _complete_chrom

    def do_max(self, arg):
        """Find position of maximum signal.  Usage: max [chrom|region]"""
        chrom, start, end = self._parse(arg)
        if chrom is None:
            if self.chrom:
                chrom = self.chrom
                start, end = 0, self.chroms[chrom]
            else:
                print("No chromosome selected. Usage: max <chrom>")
                return

        size = self.chroms.get(chrom, 0)
        start = max(0, start)
        end = min(size, end)
        span = end - start

        for ti, tr in enumerate(self.tracks):
            if chrom not in tr.chroms:
                if self.n_tracks > 1:
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    print(f"  {tc}{tr.basename}{C.RESET}: (no {chrom})")
                continue

            # Binary search for max position using binned stats
            current_start, current_end = start, end
            for _ in range(20):
                if current_end - current_start <= 100:
                    break
                nbins = min(current_end - current_start, 1000)
                stats = tr.bw.stats(chrom, current_start, current_end,
                                    type="max", nBins=nbins)
                stats = [x if x is not None else 0 for x in stats]
                max_bin = np.argmax(stats)
                bin_size = (current_end - current_start) / nbins
                current_start = max(start, int(current_start + max_bin * bin_size - bin_size))
                current_end = min(end, int(current_start + 3 * bin_size))

            vals = np.nan_to_num(
                np.array(tr.values(chrom, current_start, current_end), dtype=np.float64), nan=0.0)
            max_idx = np.argmax(vals)
            max_pos = current_start + max_idx
            max_val = vals[max_idx]

            if self.n_tracks > 1:
                tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                print(f"  {tc}{tr.basename}{C.RESET} {C.BOLD}Max:{C.RESET} {max_val:.6f}"
                      f" at {C.GREEN}{chrom}:{format_pos(max_pos)}{C.RESET}")
            else:
                print(f"  {C.BOLD}Max:{C.RESET} {max_val:.6f}"
                      f" at {C.GREEN}{chrom}:{format_pos(max_pos)}{C.RESET}")

        # Show context (use last max_pos)
        ctx = 500
        ctx_start = max(0, max_pos - ctx)
        ctx_end = min(size, max_pos + ctx)
        print(f"  {C.DIM}View context: view {chrom}:{ctx_start}-{ctx_end}{C.RESET}")

    complete_max = _complete_chrom

    def do_bed(self, arg):
        """Show signal stats for regions in a BED file.  Usage: bed <file.bed> [-v]
        -v  show sparkline for each region"""
        parts = arg.split()
        show_view = '-v' in parts
        if '-v' in parts:
            parts.remove('-v')
        if not parts:
            print("Usage: bed <file.bed> [-v]")
            return

        bedfile = os.path.expanduser(parts[0])
        if not os.path.isfile(bedfile):
            print(f"{C.RED}File not found: {bedfile}{C.RESET}")
            return

        with open(bedfile) as f:
            regions = []
            for line in f:
                line = line.strip()
                if not line or line.startswith('#') or line.startswith('track'):
                    continue
                fields = line.split('\t')
                if len(fields) < 3:
                    continue
                chrom = fields[0]
                start = int(fields[1])
                end = int(fields[2])
                name = fields[3] if len(fields) > 3 else ''
                regions.append((chrom, start, end, name))

        if not regions:
            print("  No regions found in BED file.")
            return

        print(f"  {C.DIM}{len(regions)} regions from {os.path.basename(bedfile)}{C.RESET}\n")

        for chrom, start, end, name in regions[:100]:
            if chrom not in self.chroms:
                continue

            span = end - start
            label = f"{name:>15} " if name else ""
            line = (f"  {label}{C.GREEN}{chrom}:{format_pos(start)}-{format_pos(end)}{C.RESET}"
                    f"  {format_bp(span):>10}")

            for ti, tr in enumerate(self.tracks):
                st = tr.stats(chrom, start, end, type="mean", nBins=1)
                st_max = tr.stats(chrom, start, end, type="max", nBins=1)
                mean_val = st[0] if st and st[0] is not None else 0
                max_val = st_max[0] if st_max and st_max[0] is not None else 0
                if self.n_tracks > 1:
                    tc = TRACK_ANSI[ti % len(TRACK_ANSI)]
                    line += f"  {tc}m={mean_val:.3f} M={max_val:.3f}{C.RESET}"
                else:
                    line += f"  mean={mean_val:>8.3f}  max={max_val:>8.3f}"
            print(line)

            if show_view:
                nbins = min(span, 60)
                vals = self._get_values_exact(chrom, start, end, nbins=nbins)
                print(f"  {'':>15} {C.DIM}{sparkline(vals, width=60)}{C.RESET}")

        if len(regions) > 100:
            print(f"\n  {C.YELLOW}... showing first 100 of {len(regions)} regions{C.RESET}")

    # ── Export ───────────────────────────────────────────────

    def do_export(self, arg):
        """Export region to file.  Usage: export <region> <out.npy|.bedgraph|.tsv>"""
        parts = arg.rsplit(None, 1)
        if len(parts) < 2:
            print("Usage: export <region> <output.npy|.bedgraph|.tsv>")
            return

        region_arg, outfile = parts
        chrom, start, end = self._parse(region_arg)
        if chrom is None:
            print(f"{C.RED}Cannot parse region.{C.RESET}")
            return

        size = self.chroms.get(chrom, 0)
        start = max(0, start)
        end = min(size, end)

        # Fetch all track values
        all_vals = []
        for tr in self.tracks:
            v = tr.values(chrom, start, end)
            all_vals.append(np.nan_to_num(np.array(v, dtype=np.float64), nan=0.0))

        outfile = os.path.expanduser(outfile)
        span = end - start
        if outfile.endswith('.npy'):
            if self.n_tracks == 1:
                np.save(outfile, all_vals[0])
            else:
                np.save(outfile, np.stack(all_vals))
        elif outfile.endswith('.bedgraph') or outfile.endswith('.bg'):
            if self.n_tracks > 1:
                # Write per-track bedgraph files
                base, ext = os.path.splitext(outfile)
                for ti, tr in enumerate(self.tracks):
                    fn = f"{base}.{tr.basename}{ext}"
                    with open(fn, 'w') as f:
                        for i, v in enumerate(all_vals[ti]):
                            if v != 0:
                                f.write(f"{chrom}\t{start + i}\t{start + i + 1}\t{v:.6f}\n")
                    print(f"  Saved {span:,} values -> {fn}")
                return
            else:
                with open(outfile, 'w') as f:
                    for i, v in enumerate(all_vals[0]):
                        if v != 0:
                            f.write(f"{chrom}\t{start + i}\t{start + i + 1}\t{v:.6f}\n")
        elif outfile.endswith('.tsv') or outfile.endswith('.txt'):
            with open(outfile, 'w') as f:
                hdr = "chrom\tpos"
                for tr in self.tracks:
                    hdr += f"\t{tr.basename}" if self.n_tracks > 1 else "\tvalue"
                f.write(hdr + "\n")
                for i in range(span):
                    row = f"{chrom}\t{start + i}"
                    for ti in range(self.n_tracks):
                        row += f"\t{all_vals[ti][i]:.6f}"
                    f.write(row + "\n")
        else:
            print(f"{C.RED}Unknown format. Use .npy, .bedgraph, or .tsv{C.RESET}")
            return

        print(f"  Saved {span:,} values -> {outfile}")

    # ── Help ─────────────────────────────────────────────────

    def do_help(self, arg):
        """Show help.  Usage: help [command]"""
        if arg:
            func = getattr(self, 'do_' + arg, None)
            if func and func.__doc__:
                print()
                print(func.__doc__)
                print()
            else:
                print(f"  Unknown command: {arg}")
            return

        print(f"""
{C.BOLD}Navigation{C.RESET}
  {C.GREEN}chroms{C.RESET} [-a]              List chromosomes with sizes (-a = show all)
  {C.GREEN}cd{C.RESET} <chrom>               Set current chromosome
  {C.GREEN}pwd{C.RESET}                      Current chromosome / last viewed region

{C.BOLD}Interactive Browser{C.RESET}  {C.DIM}(full-screen genome browser with keyboard navigation){C.RESET}
  {C.GREEN}browse{C.RESET} [region]            Launch interactive browser (alias: {C.GREEN}b{C.RESET}, {C.GREEN}bp{C.RESET})
  {C.DIM}  Sixel pixel rendering \u2014 requires sixel terminal (iTerm2, WezTerm, foot, xterm)
  \u2190/\u2192 h/l pan  \u2191/\u2193 k/j zoom  1-8 presets  g goto  c chrom  n nan  y ylim  t theme  s stats  q quit{C.RESET}
  {C.GREEN}bc{C.RESET} [region]                Text-mode browser (curses fallback, no sixel needed)
  {C.DIM}  Same keys + r to cycle render modes (half-block | block | braille){C.RESET}

{C.BOLD}Visualization{C.RESET}  {C.DIM}(regions: chr1:1000-2000 | 1000-2000 | chr1:1m-1.1m){C.RESET}
  {C.GREEN}view{C.RESET} <region> [-h N]      ASCII signal plot (N = plot height)
  {C.GREEN}peek{C.RESET} [chrom]              Whole-chromosome sparkline overview
  {C.GREEN}cat{C.RESET} <region>              Raw per-base values
  {C.GREEN}head{C.RESET} [-n N] [chrom]       First N bp of signal (default 20)
  {C.GREEN}tail{C.RESET} [-n N] [chrom]       Last N bp of signal

{C.BOLD}Pan & Zoom{C.RESET}  {C.DIM}(after 'view', navigate without retyping coordinates){C.RESET}
  {C.GREEN}left{C.RESET} / {C.GREEN}right{C.RESET}              Pan 25% of current view
  {C.GREEN}zoomin{C.RESET} / {C.GREEN}zi{C.RESET}               Zoom in 2x
  {C.GREEN}zoomout{C.RESET} / {C.GREEN}zo{C.RESET}              Zoom out 2x

{C.BOLD}Metadata & Stats{C.RESET}
  {C.GREEN}info{C.RESET} [chrom]              File or chromosome summary
  {C.GREEN}stats{C.RESET} <region>            Min/max/mean/std/median/percentiles/coverage
  {C.GREEN}nanmode{C.RESET} [on|off]          Toggle NaN=0 (on=mean, off=nanmean; default: on)
  {C.DIM}  In browse/bp: press {C.GREEN}n{C.DIM} to toggle{C.RESET}
  {C.GREEN}ylim{C.RESET} [ymin ymax | auto]    Set y-axis limits (default: auto)
  {C.DIM}  In browse/bp: press {C.GREEN}y{C.DIM} to set{C.RESET}

{C.BOLD}Analysis{C.RESET}
  {C.GREEN}hist{C.RESET} [-b N] <region>      Histogram of signal values
  {C.GREEN}max{C.RESET} [chrom|region]        Find position of maximum signal
  {C.GREEN}bed{C.RESET} <file.bed> [-v]       Stats for BED regions (-v = sparklines)

{C.BOLD}Export{C.RESET}
  {C.GREEN}export{C.RESET} <region> <file>    Save to .npy / .bedgraph / .tsv

{C.BOLD}Tips{C.RESET}
  {C.DIM}Coordinates support commas (1,000) and suffixes (1k, 1.5m).
  Type a chromosome name to cd into it.
  Use 'browse' (or 'b') for interactive pixel-mode navigation (sixel).
  Use 'bc' for text-mode fallback if your terminal lacks sixel support.
  Tab completion works for chromosome names.{C.RESET}
""")

    # ── Utility ──────────────────────────────────────────────

    def do_exit(self, arg):
        """Exit bwsh."""
        return True

    def do_quit(self, arg):
        """Exit bwsh."""
        return True

    def do_q(self, arg):
        """Exit bwsh."""
        return True

    def do_EOF(self, arg):
        print()
        return True

    def emptyline(self):
        pass

    def default(self, line):
        """Smart default: chromosome name -> cd, anything with : -> view."""
        name = line.strip()
        if not name:
            return

        # If it's a chromosome name, cd
        if name in self.chroms:
            self.do_cd(name)
            return

        # Case-insensitive
        for c in self.chroms:
            if c.lower() == name.lower():
                self.do_cd(c)
                return

        # If it looks like a region, view it
        if ':' in name or (self.chrom and re.match(r'^\d', name)):
            self.do_view(name)
            return

        print(f"Unknown command: {line}. Type 'help' for commands.")

    def postcmd(self, stop, line):
        return stop

    def close(self):
        for t in self.tracks:
            t.close()


# ── Entry point ──────────────────────────────────────────────

def main():
    import argparse
    import textwrap
    parser = argparse.ArgumentParser(
        description='bwsh - Interactive bigWig file explorer (supports multiple tracks)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            Interactive commands:
              chroms [-a]              list chromosomes
              cd <chrom>               set current chromosome
              view <region> [-h N]     ASCII signal plot
              peek [chrom]             whole-chromosome overview
              cat <region>             raw per-base values
              left/right/zi/zo         pan and zoom after view
              stats <region>           signal statistics
              hist <region>            signal histogram
              max [chrom]              find position of max signal
              bed <file.bed> [-v]      stats for BED regions
              export <region> <file>   save to npy/bedgraph/tsv

            Region formats:
              chr1:1000-2000   chr1:1,000-2,000   chr1:1k-2k
              chr1:1m-1.1m     1000-2000 (if cd'd)
        """),
    )
    parser.add_argument('files', nargs='+', metavar='FILE',
                        help='bigWig file(s) to open')
    parser.add_argument('--no-color', action='store_true', help='Disable colors')
    parser.add_argument('-c', '--command', help='Run command and exit')
    parser.add_argument('--chroms', action='store_true', help='List chromosomes and exit')

    args = parser.parse_args()

    for fn in args.files:
        if not os.path.isfile(fn):
            print(f"Error: {fn}: No such file", file=sys.stderr)
            sys.exit(1)

    shell = BWShell(args.files, no_color=args.no_color)

    try:
        if args.chroms:
            shell.do_chroms('')
        elif args.command:
            for cmd_line in args.command.split(';'):
                shell.onecmd(cmd_line.strip())
        else:
            shell.cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted.")
    finally:
        shell.close()


if __name__ == '__main__':
    main()
